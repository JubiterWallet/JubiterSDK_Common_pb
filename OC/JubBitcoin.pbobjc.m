// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Jub_Bitcoin.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "JubBitcoin.pbobjc.h"
#import "JubCommon.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - BitcoinProtosJubBitcoinRoot

@implementation BitcoinProtosJubBitcoinRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - BitcoinProtosJubBitcoinRoot_FileDescriptor

static GPBFileDescriptor *BitcoinProtosJubBitcoinRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"JUB.Proto.Bitcoin"
                                                 objcPrefix:@"BitcoinProtos"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum BitcoinProtosENUM_COIN_TYPE_BTC

GPBEnumDescriptor *BitcoinProtosENUM_COIN_TYPE_BTC_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Coinbtc\000Coinbch\000Coinltc\000Coinusdt\000Coindas"
        "h\000Coinqtum\000";
    static const int32_t values[] = {
        BitcoinProtosENUM_COIN_TYPE_BTC_Coinbtc,
        BitcoinProtosENUM_COIN_TYPE_BTC_Coinbch,
        BitcoinProtosENUM_COIN_TYPE_BTC_Coinltc,
        BitcoinProtosENUM_COIN_TYPE_BTC_Coinusdt,
        BitcoinProtosENUM_COIN_TYPE_BTC_Coindash,
        BitcoinProtosENUM_COIN_TYPE_BTC_Coinqtum,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BitcoinProtosENUM_COIN_TYPE_BTC)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BitcoinProtosENUM_COIN_TYPE_BTC_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BitcoinProtosENUM_COIN_TYPE_BTC_IsValidValue(int32_t value__) {
  switch (value__) {
    case BitcoinProtosENUM_COIN_TYPE_BTC_Coinbtc:
    case BitcoinProtosENUM_COIN_TYPE_BTC_Coinbch:
    case BitcoinProtosENUM_COIN_TYPE_BTC_Coinltc:
    case BitcoinProtosENUM_COIN_TYPE_BTC_Coinusdt:
    case BitcoinProtosENUM_COIN_TYPE_BTC_Coindash:
    case BitcoinProtosENUM_COIN_TYPE_BTC_Coinqtum:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BitcoinProtosENUM_TRAN_STYPE_BTC

GPBEnumDescriptor *BitcoinProtosENUM_TRAN_STYPE_BTC_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "P2Pkh\000P2ShP2Wpkh\000P2ShMultisig\000P2Pk\000";
    static const int32_t values[] = {
        BitcoinProtosENUM_TRAN_STYPE_BTC_P2Pkh,
        BitcoinProtosENUM_TRAN_STYPE_BTC_P2ShP2Wpkh,
        BitcoinProtosENUM_TRAN_STYPE_BTC_P2ShMultisig,
        BitcoinProtosENUM_TRAN_STYPE_BTC_P2Pk,
    };
    static const char *extraTextFormatInfo = "\004\000\003b\000\001\003A\203c\000\002\003A\350\000\003\003A\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BitcoinProtosENUM_TRAN_STYPE_BTC)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BitcoinProtosENUM_TRAN_STYPE_BTC_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BitcoinProtosENUM_TRAN_STYPE_BTC_IsValidValue(int32_t value__) {
  switch (value__) {
    case BitcoinProtosENUM_TRAN_STYPE_BTC_P2Pkh:
    case BitcoinProtosENUM_TRAN_STYPE_BTC_P2ShP2Wpkh:
    case BitcoinProtosENUM_TRAN_STYPE_BTC_P2ShMultisig:
    case BitcoinProtosENUM_TRAN_STYPE_BTC_P2Pk:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BitcoinProtosBTC_UNIT_TYPE

GPBEnumDescriptor *BitcoinProtosBTC_UNIT_TYPE_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Btc\000CBtc\000MBtc\000UBtc\000Satoshi\000";
    static const int32_t values[] = {
        BitcoinProtosBTC_UNIT_TYPE_Btc,
        BitcoinProtosBTC_UNIT_TYPE_CBtc,
        BitcoinProtosBTC_UNIT_TYPE_MBtc,
        BitcoinProtosBTC_UNIT_TYPE_UBtc,
        BitcoinProtosBTC_UNIT_TYPE_Satoshi,
    };
    static const char *extraTextFormatInfo = "\004\001\"b\000\002\"b\000\003\"b\000\004\007\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BitcoinProtosBTC_UNIT_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BitcoinProtosBTC_UNIT_TYPE_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BitcoinProtosBTC_UNIT_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case BitcoinProtosBTC_UNIT_TYPE_Btc:
    case BitcoinProtosBTC_UNIT_TYPE_CBtc:
    case BitcoinProtosBTC_UNIT_TYPE_MBtc:
    case BitcoinProtosBTC_UNIT_TYPE_UBtc:
    case BitcoinProtosBTC_UNIT_TYPE_Satoshi:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum BitcoinProtosENUM_SCRIPT_TYPE_BTC

GPBEnumDescriptor *BitcoinProtosENUM_SCRIPT_TYPE_BTC_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ScP2Pkh\000ScReturn0\000ScQrc20\000";
    static const int32_t values[] = {
        BitcoinProtosENUM_SCRIPT_TYPE_BTC_ScP2Pkh,
        BitcoinProtosENUM_SCRIPT_TYPE_BTC_ScReturn0,
        BitcoinProtosENUM_SCRIPT_TYPE_BTC_ScQrc20,
    };
    static const char *extraTextFormatInfo = "\001\000b\203b\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BitcoinProtosENUM_SCRIPT_TYPE_BTC)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BitcoinProtosENUM_SCRIPT_TYPE_BTC_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BitcoinProtosENUM_SCRIPT_TYPE_BTC_IsValidValue(int32_t value__) {
  switch (value__) {
    case BitcoinProtosENUM_SCRIPT_TYPE_BTC_ScP2Pkh:
    case BitcoinProtosENUM_SCRIPT_TYPE_BTC_ScReturn0:
    case BitcoinProtosENUM_SCRIPT_TYPE_BTC_ScQrc20:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BitcoinProtosContextCfgBTC

@implementation BitcoinProtosContextCfgBTC

@dynamic mainPath;
@dynamic coinType;
@dynamic transType;

typedef struct BitcoinProtosContextCfgBTC__storage_ {
  uint32_t _has_storage_[1];
  BitcoinProtosENUM_COIN_TYPE_BTC coinType;
  BitcoinProtosENUM_TRAN_STYPE_BTC transType;
  NSString *mainPath;
} BitcoinProtosContextCfgBTC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "mainPath",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosContextCfgBTC_FieldNumber_MainPath,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosContextCfgBTC__storage_, mainPath),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "coinType",
        .dataTypeSpecific.enumDescFunc = BitcoinProtosENUM_COIN_TYPE_BTC_EnumDescriptor,
        .number = BitcoinProtosContextCfgBTC_FieldNumber_CoinType,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BitcoinProtosContextCfgBTC__storage_, coinType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "transType",
        .dataTypeSpecific.enumDescFunc = BitcoinProtosENUM_TRAN_STYPE_BTC_EnumDescriptor,
        .number = BitcoinProtosContextCfgBTC_FieldNumber_TransType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BitcoinProtosContextCfgBTC__storage_, transType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosContextCfgBTC class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosContextCfgBTC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BitcoinProtosContextCfgBTC_CoinType_RawValue(BitcoinProtosContextCfgBTC *message) {
  GPBDescriptor *descriptor = [BitcoinProtosContextCfgBTC descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BitcoinProtosContextCfgBTC_FieldNumber_CoinType];
  return GPBGetMessageInt32Field(message, field);
}

void SetBitcoinProtosContextCfgBTC_CoinType_RawValue(BitcoinProtosContextCfgBTC *message, int32_t value) {
  GPBDescriptor *descriptor = [BitcoinProtosContextCfgBTC descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BitcoinProtosContextCfgBTC_FieldNumber_CoinType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t BitcoinProtosContextCfgBTC_TransType_RawValue(BitcoinProtosContextCfgBTC *message) {
  GPBDescriptor *descriptor = [BitcoinProtosContextCfgBTC descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BitcoinProtosContextCfgBTC_FieldNumber_TransType];
  return GPBGetMessageInt32Field(message, field);
}

void SetBitcoinProtosContextCfgBTC_TransType_RawValue(BitcoinProtosContextCfgBTC *message, int32_t value) {
  GPBDescriptor *descriptor = [BitcoinProtosContextCfgBTC descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BitcoinProtosContextCfgBTC_FieldNumber_TransType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - BitcoinProtosInputBTC

@implementation BitcoinProtosInputBTC

@dynamic preHash;
@dynamic preIndex;
@dynamic amount;
@dynamic hasPath, path;

typedef struct BitcoinProtosInputBTC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t preIndex;
  NSString *preHash;
  CommonProtosBip44Path *path;
  uint64_t amount;
} BitcoinProtosInputBTC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "preHash",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosInputBTC_FieldNumber_PreHash,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosInputBTC__storage_, preHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preIndex",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosInputBTC_FieldNumber_PreIndex,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BitcoinProtosInputBTC__storage_, preIndex),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosInputBTC_FieldNumber_Amount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BitcoinProtosInputBTC__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = GPBStringifySymbol(CommonProtosBip44Path),
        .number = BitcoinProtosInputBTC_FieldNumber_Path,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BitcoinProtosInputBTC__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosInputBTC class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosInputBTC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BitcoinProtosStandardOutput

@implementation BitcoinProtosStandardOutput

@dynamic address;
@dynamic amount;
@dynamic changeAddress;
@dynamic hasPath, path;

typedef struct BitcoinProtosStandardOutput__storage_ {
  uint32_t _has_storage_[1];
  NSString *address;
  CommonProtosBip44Path *path;
  uint64_t amount;
} BitcoinProtosStandardOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosStandardOutput_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosStandardOutput__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosStandardOutput_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BitcoinProtosStandardOutput__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "changeAddress",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosStandardOutput_FieldNumber_ChangeAddress,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "path",
        .dataTypeSpecific.className = GPBStringifySymbol(CommonProtosBip44Path),
        .number = BitcoinProtosStandardOutput_FieldNumber_Path,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BitcoinProtosStandardOutput__storage_, path),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosStandardOutput class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosStandardOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BitcoinProtosReturn0Output

@implementation BitcoinProtosReturn0Output

@dynamic amount;
@dynamic data_p;

typedef struct BitcoinProtosReturn0Output__storage_ {
  uint32_t _has_storage_[1];
  NSString *data_p;
  uint64_t amount;
} BitcoinProtosReturn0Output__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "amount",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosReturn0Output_FieldNumber_Amount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosReturn0Output__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosReturn0Output_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BitcoinProtosReturn0Output__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosReturn0Output class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosReturn0Output__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BitcoinProtosQRC20Output

@implementation BitcoinProtosQRC20Output

@dynamic data_p;

typedef struct BitcoinProtosQRC20Output__storage_ {
  uint32_t _has_storage_[1];
  NSString *data_p;
} BitcoinProtosQRC20Output__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosQRC20Output_FieldNumber_Data_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosQRC20Output__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosQRC20Output class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosQRC20Output__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BitcoinProtosOutputBTC

@implementation BitcoinProtosOutputBTC

@dynamic outputOneOfCase;
@dynamic type;
@dynamic stdOutput;
@dynamic return0Output;
@dynamic qrc20Output;

typedef struct BitcoinProtosOutputBTC__storage_ {
  uint32_t _has_storage_[2];
  BitcoinProtosENUM_SCRIPT_TYPE_BTC type;
  BitcoinProtosStandardOutput *stdOutput;
  BitcoinProtosReturn0Output *return0Output;
  BitcoinProtosQRC20Output *qrc20Output;
} BitcoinProtosOutputBTC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BitcoinProtosENUM_SCRIPT_TYPE_BTC_EnumDescriptor,
        .number = BitcoinProtosOutputBTC_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosOutputBTC__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "stdOutput",
        .dataTypeSpecific.className = GPBStringifySymbol(BitcoinProtosStandardOutput),
        .number = BitcoinProtosOutputBTC_FieldNumber_StdOutput,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BitcoinProtosOutputBTC__storage_, stdOutput),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "return0Output",
        .dataTypeSpecific.className = GPBStringifySymbol(BitcoinProtosReturn0Output),
        .number = BitcoinProtosOutputBTC_FieldNumber_Return0Output,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BitcoinProtosOutputBTC__storage_, return0Output),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "qrc20Output",
        .dataTypeSpecific.className = GPBStringifySymbol(BitcoinProtosQRC20Output),
        .number = BitcoinProtosOutputBTC_FieldNumber_Qrc20Output,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(BitcoinProtosOutputBTC__storage_, qrc20Output),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosOutputBTC class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosOutputBTC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "output",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BitcoinProtosOutputBTC_Type_RawValue(BitcoinProtosOutputBTC *message) {
  GPBDescriptor *descriptor = [BitcoinProtosOutputBTC descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BitcoinProtosOutputBTC_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBitcoinProtosOutputBTC_Type_RawValue(BitcoinProtosOutputBTC *message, int32_t value) {
  GPBDescriptor *descriptor = [BitcoinProtosOutputBTC descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BitcoinProtosOutputBTC_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void BitcoinProtosOutputBTC_ClearOutputOneOfCase(BitcoinProtosOutputBTC *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - BitcoinProtosTransactionBTC

@implementation BitcoinProtosTransactionBTC

@dynamic version;
@dynamic locktime;
@dynamic inputsArray, inputsArray_Count;
@dynamic outputsArray, outputsArray_Count;

typedef struct BitcoinProtosTransactionBTC__storage_ {
  uint32_t _has_storage_[1];
  uint32_t version;
  uint32_t locktime;
  NSMutableArray *inputsArray;
  NSMutableArray *outputsArray;
} BitcoinProtosTransactionBTC__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosTransactionBTC_FieldNumber_Version,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BitcoinProtosTransactionBTC__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "locktime",
        .dataTypeSpecific.className = NULL,
        .number = BitcoinProtosTransactionBTC_FieldNumber_Locktime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BitcoinProtosTransactionBTC__storage_, locktime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "inputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BitcoinProtosInputBTC),
        .number = BitcoinProtosTransactionBTC_FieldNumber_InputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BitcoinProtosTransactionBTC__storage_, inputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BitcoinProtosOutputBTC),
        .number = BitcoinProtosTransactionBTC_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BitcoinProtosTransactionBTC__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BitcoinProtosTransactionBTC class]
                                     rootClass:[BitcoinProtosJubBitcoinRoot class]
                                          file:BitcoinProtosJubBitcoinRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BitcoinProtosTransactionBTC__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
