// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: core/Tron.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "core/Tron.pbobjc.h"
#import "core/Discover.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - TronRoot

@implementation TronRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - TronRoot_FileDescriptor

static GPBFileDescriptor *TronRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"protocol"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum AccountType

GPBEnumDescriptor *AccountType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Normal\000AssetIssue\000Contract\000";
    static const int32_t values[] = {
        AccountType_Normal,
        AccountType_AssetIssue,
        AccountType_Contract,
    };
    static const char *extraTextFormatInfo = "\003\000\006\000\001\n\000\002\010\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AccountType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AccountType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AccountType_IsValidValue(int32_t value__) {
  switch (value__) {
    case AccountType_Normal:
    case AccountType_AssetIssue:
    case AccountType_Contract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ReasonCode

GPBEnumDescriptor *ReasonCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Requested\000BadProtocol\000TooManyPeers\000Dupli"
        "catePeer\000IncompatibleProtocol\000NullIdenti"
        "ty\000PeerQuiting\000UnexpectedIdentity\000LocalI"
        "dentity\000PingTimeout\000UserReason\000Reset\000Syn"
        "cFail\000FetchFail\000BadTx\000BadBlock\000Forked\000Un"
        "linkable\000IncompatibleVersion\000Incompatibl"
        "eChain\000TimeOut\000ConnectFail\000TooManyPeersW"
        "ithSameIp\000Unknown\000";
    static const int32_t values[] = {
        ReasonCode_Requested,
        ReasonCode_BadProtocol,
        ReasonCode_TooManyPeers,
        ReasonCode_DuplicatePeer,
        ReasonCode_IncompatibleProtocol,
        ReasonCode_NullIdentity,
        ReasonCode_PeerQuiting,
        ReasonCode_UnexpectedIdentity,
        ReasonCode_LocalIdentity,
        ReasonCode_PingTimeout,
        ReasonCode_UserReason,
        ReasonCode_Reset,
        ReasonCode_SyncFail,
        ReasonCode_FetchFail,
        ReasonCode_BadTx,
        ReasonCode_BadBlock,
        ReasonCode_Forked,
        ReasonCode_Unlinkable,
        ReasonCode_IncompatibleVersion,
        ReasonCode_IncompatibleChain,
        ReasonCode_TimeOut,
        ReasonCode_ConnectFail,
        ReasonCode_TooManyPeersWithSameIp,
        ReasonCode_Unknown,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ReasonCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ReasonCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ReasonCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ReasonCode_Requested:
    case ReasonCode_BadProtocol:
    case ReasonCode_TooManyPeers:
    case ReasonCode_DuplicatePeer:
    case ReasonCode_IncompatibleProtocol:
    case ReasonCode_NullIdentity:
    case ReasonCode_PeerQuiting:
    case ReasonCode_UnexpectedIdentity:
    case ReasonCode_LocalIdentity:
    case ReasonCode_PingTimeout:
    case ReasonCode_UserReason:
    case ReasonCode_Reset:
    case ReasonCode_SyncFail:
    case ReasonCode_FetchFail:
    case ReasonCode_BadTx:
    case ReasonCode_BadBlock:
    case ReasonCode_Forked:
    case ReasonCode_Unlinkable:
    case ReasonCode_IncompatibleVersion:
    case ReasonCode_IncompatibleChain:
    case ReasonCode_TimeOut:
    case ReasonCode_ConnectFail:
    case ReasonCode_TooManyPeersWithSameIp:
    case ReasonCode_Unknown:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - AccountId

@implementation AccountId

@dynamic name;
@dynamic address;

typedef struct AccountId__storage_ {
  uint32_t _has_storage_[1];
  NSData *name;
  NSData *address;
} AccountId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = AccountId_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(AccountId__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = AccountId_FieldNumber_Address,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(AccountId__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[AccountId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(AccountId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Vote

@implementation Vote

@dynamic voteAddress;
@dynamic voteCount;

typedef struct Vote__storage_ {
  uint32_t _has_storage_[1];
  NSData *voteAddress;
  int64_t voteCount;
} Vote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "voteAddress",
        .dataTypeSpecific.className = NULL,
        .number = Vote_FieldNumber_VoteAddress,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Vote__storage_, voteAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = Vote_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Vote__storage_, voteCount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Vote class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Vote__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Proposal

@implementation Proposal

@dynamic proposalId;
@dynamic proposerAddress;
@dynamic parameters, parameters_Count;
@dynamic expirationTime;
@dynamic createTime;
@dynamic approvalsArray, approvalsArray_Count;
@dynamic state;

typedef struct Proposal__storage_ {
  uint32_t _has_storage_[1];
  Proposal_State state;
  NSData *proposerAddress;
  GPBInt64Int64Dictionary *parameters;
  NSMutableArray *approvalsArray;
  int64_t proposalId;
  int64_t expirationTime;
  int64_t createTime;
} Proposal__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "proposalId",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ProposalId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Proposal__storage_, proposalId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "proposerAddress",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ProposerAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Proposal__storage_, proposerAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parameters",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_Parameters,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Proposal__storage_, parameters),
        .flags = GPBFieldMapKeyInt64,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expirationTime",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ExpirationTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Proposal__storage_, expirationTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_CreateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Proposal__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "approvalsArray",
        .dataTypeSpecific.className = NULL,
        .number = Proposal_FieldNumber_ApprovalsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Proposal__storage_, approvalsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = Proposal_State_EnumDescriptor,
        .number = Proposal_FieldNumber_State,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Proposal__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Proposal class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Proposal__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Proposal_State_RawValue(Proposal *message) {
  GPBDescriptor *descriptor = [Proposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetProposal_State_RawValue(Proposal *message, int32_t value) {
  GPBDescriptor *descriptor = [Proposal descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Proposal_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Proposal_State

GPBEnumDescriptor *Proposal_State_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Pending\000Disapproved\000Approved\000Canceled\000";
    static const int32_t values[] = {
        Proposal_State_Pending,
        Proposal_State_Disapproved,
        Proposal_State_Approved,
        Proposal_State_Canceled,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Proposal_State)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Proposal_State_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Proposal_State_IsValidValue(int32_t value__) {
  switch (value__) {
    case Proposal_State_Pending:
    case Proposal_State_Disapproved:
    case Proposal_State_Approved:
    case Proposal_State_Canceled:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Exchange

@implementation Exchange

@dynamic exchangeId;
@dynamic creatorAddress;
@dynamic createTime;
@dynamic firstTokenId;
@dynamic firstTokenBalance;
@dynamic secondTokenId;
@dynamic secondTokenBalance;

typedef struct Exchange__storage_ {
  uint32_t _has_storage_[1];
  NSData *creatorAddress;
  NSData *firstTokenId;
  NSData *secondTokenId;
  int64_t exchangeId;
  int64_t createTime;
  int64_t firstTokenBalance;
  int64_t secondTokenBalance;
} Exchange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_ExchangeId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Exchange__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "creatorAddress",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_CreatorAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Exchange__storage_, creatorAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_CreateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Exchange__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "firstTokenId",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_FirstTokenId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Exchange__storage_, firstTokenId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "firstTokenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_FirstTokenBalance,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Exchange__storage_, firstTokenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "secondTokenId",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_SecondTokenId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Exchange__storage_, secondTokenId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "secondTokenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Exchange_FieldNumber_SecondTokenBalance,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Exchange__storage_, secondTokenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Exchange class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Exchange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainParameters

@implementation ChainParameters

@dynamic chainParameterArray, chainParameterArray_Count;

typedef struct ChainParameters__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *chainParameterArray;
} ChainParameters__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chainParameterArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainParameters_ChainParameter),
        .number = ChainParameters_FieldNumber_ChainParameterArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainParameters__storage_, chainParameterArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainParameters class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainParameters__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\000chainParameter\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainParameters_ChainParameter

@implementation ChainParameters_ChainParameter

@dynamic key;
@dynamic value;

typedef struct ChainParameters_ChainParameter__storage_ {
  uint32_t _has_storage_[1];
  NSString *key;
  int64_t value;
} ChainParameters_ChainParameter__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "key",
        .dataTypeSpecific.className = NULL,
        .number = ChainParameters_ChainParameter_FieldNumber_Key,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainParameters_ChainParameter__storage_, key),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = ChainParameters_ChainParameter_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainParameters_ChainParameter__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainParameters_ChainParameter class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainParameters_ChainParameter__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChainParameters)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account

@implementation Account

@dynamic accountName;
@dynamic type;
@dynamic address;
@dynamic balance;
@dynamic votesArray, votesArray_Count;
@dynamic asset, asset_Count;
@dynamic assetV2, assetV2_Count;
@dynamic frozenArray, frozenArray_Count;
@dynamic netUsage;
@dynamic acquiredDelegatedFrozenBalanceForBandwidth;
@dynamic delegatedFrozenBalanceForBandwidth;
@dynamic createTime;
@dynamic latestOprationTime;
@dynamic allowance;
@dynamic latestWithdrawTime;
@dynamic code;
@dynamic isWitness;
@dynamic isCommittee;
@dynamic frozenSupplyArray, frozenSupplyArray_Count;
@dynamic assetIssuedName;
@dynamic assetIssuedId;
@dynamic latestAssetOperationTime, latestAssetOperationTime_Count;
@dynamic latestAssetOperationTimeV2, latestAssetOperationTimeV2_Count;
@dynamic freeNetUsage;
@dynamic freeAssetNetUsage, freeAssetNetUsage_Count;
@dynamic freeAssetNetUsageV2, freeAssetNetUsageV2_Count;
@dynamic latestConsumeTime;
@dynamic latestConsumeFreeTime;
@dynamic accountId;
@dynamic hasAccountResource, accountResource;
@dynamic codeHash;
@dynamic hasOwnerPermission, ownerPermission;
@dynamic hasWitnessPermission, witnessPermission;
@dynamic activePermissionArray, activePermissionArray_Count;

typedef struct Account__storage_ {
  uint32_t _has_storage_[1];
  AccountType type;
  NSData *accountName;
  NSData *address;
  NSMutableArray *votesArray;
  GPBStringInt64Dictionary *asset;
  NSMutableArray *frozenArray;
  NSData *code;
  NSMutableArray *frozenSupplyArray;
  NSData *assetIssuedName;
  GPBStringInt64Dictionary *latestAssetOperationTime;
  GPBStringInt64Dictionary *freeAssetNetUsage;
  NSData *accountId;
  Account_AccountResource *accountResource;
  NSData *codeHash;
  Permission *ownerPermission;
  Permission *witnessPermission;
  NSMutableArray *activePermissionArray;
  GPBStringInt64Dictionary *assetV2;
  NSData *assetIssuedId;
  GPBStringInt64Dictionary *latestAssetOperationTimeV2;
  GPBStringInt64Dictionary *freeAssetNetUsageV2;
  int64_t balance;
  int64_t netUsage;
  int64_t createTime;
  int64_t latestOprationTime;
  int64_t allowance;
  int64_t latestWithdrawTime;
  int64_t freeNetUsage;
  int64_t latestConsumeTime;
  int64_t latestConsumeFreeTime;
  int64_t acquiredDelegatedFrozenBalanceForBandwidth;
  int64_t delegatedFrozenBalanceForBandwidth;
} Account__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "accountName",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountName,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account__storage_, accountName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = AccountType_EnumDescriptor,
        .number = Account_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Address,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "balance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Balance,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account__storage_, balance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "votesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Account_FieldNumber_VotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, votesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "asset",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Asset,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, asset),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_FieldNumber_FrozenArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, frozenArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "netUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_NetUsage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account__storage_, netUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "createTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_CreateTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Account__storage_, createTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestOprationTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestOprationTime,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Account__storage_, latestOprationTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "allowance",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Allowance,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Account__storage_, allowance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestWithdrawTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestWithdrawTime,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Account__storage_, latestWithdrawTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "code",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_Code,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(Account__storage_, code),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "isWitness",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_IsWitness,
        .hasIndex = 12,
        .offset = 13,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "isCommittee",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_IsCommittee,
        .hasIndex = 14,
        .offset = 15,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "frozenSupplyArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_FieldNumber_FrozenSupplyArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, frozenSupplyArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "assetIssuedName",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AssetIssuedName,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(Account__storage_, assetIssuedName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "latestAssetOperationTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestAssetOperationTime,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, latestAssetOperationTime),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeNetUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeNetUsage,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(Account__storage_, freeNetUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeAssetNetUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeAssetNetUsage,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, freeAssetNetUsage),
        .flags = GPBFieldMapKeyString,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestConsumeTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestConsumeTime,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(Account__storage_, latestConsumeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestConsumeFreeTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestConsumeFreeTime,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(Account__storage_, latestConsumeFreeTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "accountId",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AccountId,
        .hasIndex = 21,
        .offset = (uint32_t)offsetof(Account__storage_, accountId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "accountResource",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_AccountResource),
        .number = Account_FieldNumber_AccountResource,
        .hasIndex = 22,
        .offset = (uint32_t)offsetof(Account__storage_, accountResource),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "codeHash",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_CodeHash,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(Account__storage_, codeHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "ownerPermission",
        .dataTypeSpecific.className = GPBStringifySymbol(Permission),
        .number = Account_FieldNumber_OwnerPermission,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(Account__storage_, ownerPermission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witnessPermission",
        .dataTypeSpecific.className = GPBStringifySymbol(Permission),
        .number = Account_FieldNumber_WitnessPermission,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(Account__storage_, witnessPermission),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "activePermissionArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Permission),
        .number = Account_FieldNumber_ActivePermissionArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, activePermissionArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "acquiredDelegatedFrozenBalanceForBandwidth",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AcquiredDelegatedFrozenBalanceForBandwidth,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Account__storage_, acquiredDelegatedFrozenBalanceForBandwidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "delegatedFrozenBalanceForBandwidth",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_DelegatedFrozenBalanceForBandwidth,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Account__storage_, delegatedFrozenBalanceForBandwidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "assetV2",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AssetV2,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, assetV2),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "assetIssuedId",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_AssetIssuedId,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(Account__storage_, assetIssuedId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "latestAssetOperationTimeV2",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_LatestAssetOperationTimeV2,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, latestAssetOperationTimeV2),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeAssetNetUsageV2",
        .dataTypeSpecific.className = NULL,
        .number = Account_FieldNumber_FreeAssetNetUsageV2,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Account__storage_, freeAssetNetUsageV2),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\036\010\0008\007\0009\005\246\342\000:\006\245\251\246\000;\004\245\243\247\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Account_Type_RawValue(Account *message) {
  GPBDescriptor *descriptor = [Account descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetAccount_Type_RawValue(Account *message, int32_t value) {
  GPBDescriptor *descriptor = [Account descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Account_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Account_Frozen

@implementation Account_Frozen

@dynamic frozenBalance;
@dynamic expireTime;

typedef struct Account_Frozen__storage_ {
  uint32_t _has_storage_[1];
  int64_t frozenBalance;
  int64_t expireTime;
} Account_Frozen__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "frozenBalance",
        .dataTypeSpecific.className = NULL,
        .number = Account_Frozen_FieldNumber_FrozenBalance,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account_Frozen__storage_, frozenBalance),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expireTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_Frozen_FieldNumber_ExpireTime,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account_Frozen__storage_, expireTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account_Frozen class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_Frozen__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Account)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Account_AccountResource

@implementation Account_AccountResource

@dynamic energyUsage;
@dynamic hasFrozenBalanceForEnergy, frozenBalanceForEnergy;
@dynamic latestConsumeTimeForEnergy;
@dynamic acquiredDelegatedFrozenBalanceForEnergy;
@dynamic delegatedFrozenBalanceForEnergy;
@dynamic storageLimit;
@dynamic storageUsage;
@dynamic latestExchangeStorageTime;

typedef struct Account_AccountResource__storage_ {
  uint32_t _has_storage_[1];
  Account_Frozen *frozenBalanceForEnergy;
  int64_t energyUsage;
  int64_t latestConsumeTimeForEnergy;
  int64_t acquiredDelegatedFrozenBalanceForEnergy;
  int64_t delegatedFrozenBalanceForEnergy;
  int64_t storageLimit;
  int64_t storageUsage;
  int64_t latestExchangeStorageTime;
} Account_AccountResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "energyUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_EnergyUsage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, energyUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenBalanceForEnergy",
        .dataTypeSpecific.className = GPBStringifySymbol(Account_Frozen),
        .number = Account_AccountResource_FieldNumber_FrozenBalanceForEnergy,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, frozenBalanceForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latestConsumeTimeForEnergy",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_LatestConsumeTimeForEnergy,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, latestConsumeTimeForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "acquiredDelegatedFrozenBalanceForEnergy",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_AcquiredDelegatedFrozenBalanceForEnergy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, acquiredDelegatedFrozenBalanceForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "delegatedFrozenBalanceForEnergy",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_DelegatedFrozenBalanceForEnergy,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, delegatedFrozenBalanceForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "storageLimit",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_StorageLimit,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, storageLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "storageUsage",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_StorageUsage,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, storageUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestExchangeStorageTime",
        .dataTypeSpecific.className = NULL,
        .number = Account_AccountResource_FieldNumber_LatestExchangeStorageTime,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Account_AccountResource__storage_, latestExchangeStorageTime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Account_AccountResource class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Account_AccountResource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Account)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Key

@implementation Key

@dynamic address;
@dynamic weight;

typedef struct Key__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  int64_t weight;
} Key__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Key_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Key__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "weight",
        .dataTypeSpecific.className = NULL,
        .number = Key_FieldNumber_Weight,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Key__storage_, weight),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Key class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Key__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelegatedResource

@implementation DelegatedResource

@dynamic from;
@dynamic to;
@dynamic frozenBalanceForBandwidth;
@dynamic frozenBalanceForEnergy;
@dynamic expireTimeForBandwidth;
@dynamic expireTimeForEnergy;

typedef struct DelegatedResource__storage_ {
  uint32_t _has_storage_[1];
  NSData *from;
  NSData *to;
  int64_t frozenBalanceForBandwidth;
  int64_t frozenBalanceForEnergy;
  int64_t expireTimeForBandwidth;
  int64_t expireTimeForEnergy;
} DelegatedResource__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResource_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelegatedResource__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "to",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResource_FieldNumber_To,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DelegatedResource__storage_, to),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "frozenBalanceForBandwidth",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResource_FieldNumber_FrozenBalanceForBandwidth,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DelegatedResource__storage_, frozenBalanceForBandwidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "frozenBalanceForEnergy",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResource_FieldNumber_FrozenBalanceForEnergy,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DelegatedResource__storage_, frozenBalanceForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expireTimeForBandwidth",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResource_FieldNumber_ExpireTimeForBandwidth,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DelegatedResource__storage_, expireTimeForBandwidth),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "expireTimeForEnergy",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResource_FieldNumber_ExpireTimeForEnergy,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DelegatedResource__storage_, expireTimeForEnergy),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelegatedResource class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResource__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - authority

@implementation authority

@dynamic hasAccount, account;
@dynamic permissionName;

typedef struct authority__storage_ {
  uint32_t _has_storage_[1];
  AccountId *account;
  NSData *permissionName;
} authority__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = GPBStringifySymbol(AccountId),
        .number = authority_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(authority__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "permissionName",
        .dataTypeSpecific.className = NULL,
        .number = authority_FieldNumber_PermissionName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(authority__storage_, permissionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[authority class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(authority__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Permission

@implementation Permission

@dynamic type;
@dynamic id_p;
@dynamic permissionName;
@dynamic threshold;
@dynamic parentId;
@dynamic operations;
@dynamic keysArray, keysArray_Count;

typedef struct Permission__storage_ {
  uint32_t _has_storage_[1];
  Permission_PermissionType type;
  int32_t id_p;
  int32_t parentId;
  NSString *permissionName;
  NSData *operations;
  NSMutableArray *keysArray;
  int64_t threshold;
} Permission__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Permission_PermissionType_EnumDescriptor,
        .number = Permission_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Permission__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Permission_FieldNumber_Id_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Permission__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "permissionName",
        .dataTypeSpecific.className = NULL,
        .number = Permission_FieldNumber_PermissionName,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Permission__storage_, permissionName),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "threshold",
        .dataTypeSpecific.className = NULL,
        .number = Permission_FieldNumber_Threshold,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Permission__storage_, threshold),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "parentId",
        .dataTypeSpecific.className = NULL,
        .number = Permission_FieldNumber_ParentId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Permission__storage_, parentId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "operations",
        .dataTypeSpecific.className = NULL,
        .number = Permission_FieldNumber_Operations,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Permission__storage_, operations),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "keysArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Key),
        .number = Permission_FieldNumber_KeysArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Permission__storage_, keysArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Permission class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Permission__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Permission_Type_RawValue(Permission *message) {
  GPBDescriptor *descriptor = [Permission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Permission_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetPermission_Type_RawValue(Permission *message, int32_t value) {
  GPBDescriptor *descriptor = [Permission descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Permission_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Permission_PermissionType

GPBEnumDescriptor *Permission_PermissionType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Owner\000Witness\000Active\000";
    static const int32_t values[] = {
        Permission_PermissionType_Owner,
        Permission_PermissionType_Witness,
        Permission_PermissionType_Active,
    };
    static const char *extraTextFormatInfo = "\003\000\005\000\001\007\000\002\006\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Permission_PermissionType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Permission_PermissionType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Permission_PermissionType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Permission_PermissionType_Owner:
    case Permission_PermissionType_Witness:
    case Permission_PermissionType_Active:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Witness

@implementation Witness

@dynamic address;
@dynamic voteCount;
@dynamic pubKey;
@dynamic URL;
@dynamic totalProduced;
@dynamic totalMissed;
@dynamic latestBlockNum;
@dynamic latestSlotNum;
@dynamic isJobs;

typedef struct Witness__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSData *pubKey;
  NSString *URL;
  int64_t voteCount;
  int64_t totalProduced;
  int64_t totalMissed;
  int64_t latestBlockNum;
  int64_t latestSlotNum;
} Witness__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Witness__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "voteCount",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_VoteCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Witness__storage_, voteCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Witness__storage_, pubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_URL,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Witness__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "totalProduced",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_TotalProduced,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Witness__storage_, totalProduced),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "totalMissed",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_TotalMissed,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Witness__storage_, totalMissed),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_LatestBlockNum,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Witness__storage_, latestBlockNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "latestSlotNum",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_LatestSlotNum,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Witness__storage_, latestSlotNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "isJobs",
        .dataTypeSpecific.className = NULL,
        .number = Witness_FieldNumber_IsJobs,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Witness class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Witness__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\010\002\t\000\003\006\000\004!!!\000\005\r\000\006\013\000\007\016\000\010\r\000\t\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Votes

@implementation Votes

@dynamic address;
@dynamic oldVotesArray, oldVotesArray_Count;
@dynamic newVotesArray, newVotesArray_Count;

typedef struct Votes__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *oldVotesArray;
  NSMutableArray *newVotesArray;
} Votes__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = Votes_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Votes__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "oldVotesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Votes_FieldNumber_OldVotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Votes__storage_, oldVotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "newVotesArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Vote),
        .number = Votes_FieldNumber_NewVotesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Votes__storage_, newVotesArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Votes class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Votes__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXOutput

@implementation TXOutput

@dynamic value;
@dynamic pubKeyHash;

typedef struct TXOutput__storage_ {
  uint32_t _has_storage_[1];
  NSData *pubKeyHash;
  int64_t value;
} TXOutput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = TXOutput_FieldNumber_Value,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXOutput__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKeyHash",
        .dataTypeSpecific.className = NULL,
        .number = TXOutput_FieldNumber_PubKeyHash,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXOutput__storage_, pubKeyHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXOutput class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXInput

@implementation TXInput

@dynamic hasRawData, rawData;
@dynamic signature;

typedef struct TXInput__storage_ {
  uint32_t _has_storage_[1];
  TXInput_raw *rawData;
  NSData *signature;
} TXInput__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(TXInput_raw),
        .number = TXInput_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXInput__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signature",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_FieldNumber_Signature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXInput__storage_, signature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXInput class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXInput_raw

@implementation TXInput_raw

@dynamic txId;
@dynamic vout;
@dynamic pubKey;

typedef struct TXInput_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *txId;
  NSData *pubKey;
  int64_t vout;
} TXInput_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "txId",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_TxId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, txId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "vout",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_Vout,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, vout),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "pubKey",
        .dataTypeSpecific.className = NULL,
        .number = TXInput_raw_FieldNumber_PubKey,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TXInput_raw__storage_, pubKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXInput_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXInput_raw__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\003A\000\003\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TXInput)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TXOutputs

@implementation TXOutputs

@dynamic outputsArray, outputsArray_Count;

typedef struct TXOutputs__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *outputsArray;
} TXOutputs__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "outputsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TXOutput),
        .number = TXOutputs_FieldNumber_OutputsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TXOutputs__storage_, outputsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TXOutputs class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TXOutputs__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResourceReceipt

@implementation ResourceReceipt

@dynamic energyUsage;
@dynamic energyFee;
@dynamic originEnergyUsage;
@dynamic energyUsageTotal;
@dynamic netUsage;
@dynamic netFee;
@dynamic result;

typedef struct ResourceReceipt__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Result_contractResult result;
  int64_t energyUsage;
  int64_t energyFee;
  int64_t originEnergyUsage;
  int64_t energyUsageTotal;
  int64_t netUsage;
  int64_t netFee;
} ResourceReceipt__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "energyUsage",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_EnergyUsage,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "energyFee",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_EnergyFee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "originEnergyUsage",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_OriginEnergyUsage,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, originEnergyUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "energyUsageTotal",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_EnergyUsageTotal,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, energyUsageTotal),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "netUsage",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_NetUsage,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, netUsage),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "netFee",
        .dataTypeSpecific.className = NULL,
        .number = ResourceReceipt_FieldNumber_NetFee,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, netFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = Transaction_Result_contractResult_EnumDescriptor,
        .number = ResourceReceipt_FieldNumber_Result,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(ResourceReceipt__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResourceReceipt class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResourceReceipt__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ResourceReceipt_Result_RawValue(ResourceReceipt *message) {
  GPBDescriptor *descriptor = [ResourceReceipt descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResourceReceipt_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetResourceReceipt_Result_RawValue(ResourceReceipt *message, int32_t value) {
  GPBDescriptor *descriptor = [ResourceReceipt descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ResourceReceipt_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Transaction

@implementation Transaction

@dynamic hasRawData, rawData;
@dynamic signatureArray, signatureArray_Count;
@dynamic retArray, retArray_Count;

typedef struct Transaction__storage_ {
  uint32_t _has_storage_[1];
  Transaction_raw *rawData;
  NSMutableArray *signatureArray;
  NSMutableArray *retArray;
} Transaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_raw),
        .number = Transaction_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "signatureArray",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_FieldNumber_SignatureArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, signatureArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "retArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Result),
        .number = Transaction_FieldNumber_RetArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction__storage_, retArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transaction_Contract

@implementation Transaction_Contract

@dynamic type;
@dynamic hasParameter, parameter;
@dynamic provider;
@dynamic contractName;
@dynamic permissionId;

typedef struct Transaction_Contract__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Contract_ContractType type;
  int32_t permissionId;
  GPBAny *parameter;
  NSData *provider;
  NSData *contractName;
} Transaction_Contract__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Transaction_Contract_ContractType_EnumDescriptor,
        .number = Transaction_Contract_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "parameter",
        .dataTypeSpecific.className = GPBStringifySymbol(GPBAny),
        .number = Transaction_Contract_FieldNumber_Parameter,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, parameter),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "provider",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_Provider,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, provider),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractName",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_ContractName,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, contractName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "permissionId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Contract_FieldNumber_PermissionId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_Contract__storage_, permissionId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Contract class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Contract__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004L\000\005J\242\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_Contract_Type_RawValue(Transaction_Contract *message) {
  GPBDescriptor *descriptor = [Transaction_Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Contract_Type_RawValue(Transaction_Contract *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Contract descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Contract_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_Contract_ContractType

GPBEnumDescriptor *Transaction_Contract_ContractType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "AccountCreateContract\000TransferContract\000T"
        "ransferAssetContract\000VoteAssetContract\000V"
        "oteWitnessContract\000WitnessCreateContract"
        "\000AssetIssueContract\000WitnessUpdateContrac"
        "t\000ParticipateAssetIssueContract\000AccountU"
        "pdateContract\000FreezeBalanceContract\000Unfr"
        "eezeBalanceContract\000WithdrawBalanceContr"
        "act\000UnfreezeAssetContract\000UpdateAssetCon"
        "tract\000ProposalCreateContract\000ProposalApp"
        "roveContract\000ProposalDeleteContract\000SetA"
        "ccountIdContract\000CustomContract\000CreateSm"
        "artContract\000TriggerSmartContract\000GetCont"
        "ract\000UpdateSettingContract\000ExchangeCreat"
        "eContract\000ExchangeInjectContract\000Exchang"
        "eWithdrawContract\000ExchangeTransactionCon"
        "tract\000UpdateEnergyLimitContract\000AccountP"
        "ermissionUpdateContract\000ClearAbicontract"
        "\000UpdateBrokerageContract\000ShieldedTransfe"
        "rContract\000";
    static const int32_t values[] = {
        Transaction_Contract_ContractType_AccountCreateContract,
        Transaction_Contract_ContractType_TransferContract,
        Transaction_Contract_ContractType_TransferAssetContract,
        Transaction_Contract_ContractType_VoteAssetContract,
        Transaction_Contract_ContractType_VoteWitnessContract,
        Transaction_Contract_ContractType_WitnessCreateContract,
        Transaction_Contract_ContractType_AssetIssueContract,
        Transaction_Contract_ContractType_WitnessUpdateContract,
        Transaction_Contract_ContractType_ParticipateAssetIssueContract,
        Transaction_Contract_ContractType_AccountUpdateContract,
        Transaction_Contract_ContractType_FreezeBalanceContract,
        Transaction_Contract_ContractType_UnfreezeBalanceContract,
        Transaction_Contract_ContractType_WithdrawBalanceContract,
        Transaction_Contract_ContractType_UnfreezeAssetContract,
        Transaction_Contract_ContractType_UpdateAssetContract,
        Transaction_Contract_ContractType_ProposalCreateContract,
        Transaction_Contract_ContractType_ProposalApproveContract,
        Transaction_Contract_ContractType_ProposalDeleteContract,
        Transaction_Contract_ContractType_SetAccountIdContract,
        Transaction_Contract_ContractType_CustomContract,
        Transaction_Contract_ContractType_CreateSmartContract,
        Transaction_Contract_ContractType_TriggerSmartContract,
        Transaction_Contract_ContractType_GetContract,
        Transaction_Contract_ContractType_UpdateSettingContract,
        Transaction_Contract_ContractType_ExchangeCreateContract,
        Transaction_Contract_ContractType_ExchangeInjectContract,
        Transaction_Contract_ContractType_ExchangeWithdrawContract,
        Transaction_Contract_ContractType_ExchangeTransactionContract,
        Transaction_Contract_ContractType_UpdateEnergyLimitContract,
        Transaction_Contract_ContractType_AccountPermissionUpdateContract,
        Transaction_Contract_ContractType_ClearAbicontract,
        Transaction_Contract_ContractType_UpdateBrokerageContract,
        Transaction_Contract_ContractType_ShieldedTransferContract,
    };
    static const char *extraTextFormatInfo = "!\000\025\000\001\020\000\002\025\000\003\021\000\004\023\000\005\025\000\006\022\000\007\025\000\010\035\000\t\025\000\n\025\000\013\027\000\014\027\000\r\025\000\016\023\000\017\026\000\020\027\000\021\026\000\022\024\000\023\016\000\024\023\000\025\024\000\026\013\000\027\025\000\030\026\000\031\026\000\032\030\000\033\033\000\034\031\000\035\037\000\036\006c\007\000\037\027\000 \030\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Contract_ContractType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Contract_ContractType_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Contract_ContractType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Contract_ContractType_AccountCreateContract:
    case Transaction_Contract_ContractType_TransferContract:
    case Transaction_Contract_ContractType_TransferAssetContract:
    case Transaction_Contract_ContractType_VoteAssetContract:
    case Transaction_Contract_ContractType_VoteWitnessContract:
    case Transaction_Contract_ContractType_WitnessCreateContract:
    case Transaction_Contract_ContractType_AssetIssueContract:
    case Transaction_Contract_ContractType_WitnessUpdateContract:
    case Transaction_Contract_ContractType_ParticipateAssetIssueContract:
    case Transaction_Contract_ContractType_AccountUpdateContract:
    case Transaction_Contract_ContractType_FreezeBalanceContract:
    case Transaction_Contract_ContractType_UnfreezeBalanceContract:
    case Transaction_Contract_ContractType_WithdrawBalanceContract:
    case Transaction_Contract_ContractType_UnfreezeAssetContract:
    case Transaction_Contract_ContractType_UpdateAssetContract:
    case Transaction_Contract_ContractType_ProposalCreateContract:
    case Transaction_Contract_ContractType_ProposalApproveContract:
    case Transaction_Contract_ContractType_ProposalDeleteContract:
    case Transaction_Contract_ContractType_SetAccountIdContract:
    case Transaction_Contract_ContractType_CustomContract:
    case Transaction_Contract_ContractType_CreateSmartContract:
    case Transaction_Contract_ContractType_TriggerSmartContract:
    case Transaction_Contract_ContractType_GetContract:
    case Transaction_Contract_ContractType_UpdateSettingContract:
    case Transaction_Contract_ContractType_ExchangeCreateContract:
    case Transaction_Contract_ContractType_ExchangeInjectContract:
    case Transaction_Contract_ContractType_ExchangeWithdrawContract:
    case Transaction_Contract_ContractType_ExchangeTransactionContract:
    case Transaction_Contract_ContractType_UpdateEnergyLimitContract:
    case Transaction_Contract_ContractType_AccountPermissionUpdateContract:
    case Transaction_Contract_ContractType_ClearAbicontract:
    case Transaction_Contract_ContractType_UpdateBrokerageContract:
    case Transaction_Contract_ContractType_ShieldedTransferContract:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_Result

@implementation Transaction_Result

@dynamic fee;
@dynamic ret;
@dynamic contractRet;
@dynamic assetIssueId;
@dynamic withdrawAmount;
@dynamic unfreezeAmount;
@dynamic exchangeReceivedAmount;
@dynamic exchangeInjectAnotherAmount;
@dynamic exchangeWithdrawAnotherAmount;
@dynamic exchangeId;
@dynamic shieldedTransactionFee;

typedef struct Transaction_Result__storage_ {
  uint32_t _has_storage_[1];
  Transaction_Result_code ret;
  Transaction_Result_contractResult contractRet;
  NSString *assetIssueId;
  int64_t fee;
  int64_t withdrawAmount;
  int64_t unfreezeAmount;
  int64_t exchangeReceivedAmount;
  int64_t exchangeInjectAnotherAmount;
  int64_t exchangeWithdrawAnotherAmount;
  int64_t exchangeId;
  int64_t shieldedTransactionFee;
} Transaction_Result__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_Fee,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "ret",
        .dataTypeSpecific.enumDescFunc = Transaction_Result_code_EnumDescriptor,
        .number = Transaction_Result_FieldNumber_Ret,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, ret),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "contractRet",
        .dataTypeSpecific.enumDescFunc = Transaction_Result_contractResult_EnumDescriptor,
        .number = Transaction_Result_FieldNumber_ContractRet,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, contractRet),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "assetIssueId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_AssetIssueId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, assetIssueId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "withdrawAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_WithdrawAmount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, withdrawAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unfreezeAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_UnfreezeAmount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, unfreezeAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeReceivedAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_ExchangeReceivedAmount,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeReceivedAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeInjectAnotherAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_ExchangeInjectAnotherAmount,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeInjectAnotherAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeWithdrawAnotherAmount",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_ExchangeWithdrawAnotherAmount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeWithdrawAnotherAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_ExchangeId,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shieldedTransactionFee",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_Result_FieldNumber_ShieldedTransactionFee,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(Transaction_Result__storage_, shieldedTransactionFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_Result class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_Result__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\013\000\016\013A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Transaction_Result_Ret_RawValue(Transaction_Result *message) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Result_Ret_RawValue(Transaction_Result *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_Ret];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t Transaction_Result_ContractRet_RawValue(Transaction_Result *message) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_ContractRet];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransaction_Result_ContractRet_RawValue(Transaction_Result *message, int32_t value) {
  GPBDescriptor *descriptor = [Transaction_Result descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Transaction_Result_FieldNumber_ContractRet];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Transaction_Result_code

GPBEnumDescriptor *Transaction_Result_code_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Sucess\000Failed\000";
    static const int32_t values[] = {
        Transaction_Result_code_Sucess,
        Transaction_Result_code_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Result_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Result_code_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Result_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Result_code_Sucess:
    case Transaction_Result_code_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Transaction_Result_contractResult

GPBEnumDescriptor *Transaction_Result_contractResult_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Default\000Success\000Revert\000BadJumpDestinatio"
        "n\000OutOfMemory\000PrecompiledContract\000StackT"
        "ooSmall\000StackTooLarge\000IllegalOperation\000S"
        "tackOverflow\000OutOfEnergy\000OutOfTime\000JvmSt"
        "ackOverFlow\000Unknown\000TransferFailed\000";
    static const int32_t values[] = {
        Transaction_Result_contractResult_Default,
        Transaction_Result_contractResult_Success,
        Transaction_Result_contractResult_Revert,
        Transaction_Result_contractResult_BadJumpDestination,
        Transaction_Result_contractResult_OutOfMemory,
        Transaction_Result_contractResult_PrecompiledContract,
        Transaction_Result_contractResult_StackTooSmall,
        Transaction_Result_contractResult_StackTooLarge,
        Transaction_Result_contractResult_IllegalOperation,
        Transaction_Result_contractResult_StackOverflow,
        Transaction_Result_contractResult_OutOfEnergy,
        Transaction_Result_contractResult_OutOfTime,
        Transaction_Result_contractResult_JvmStackOverFlow,
        Transaction_Result_contractResult_Unknown,
        Transaction_Result_contractResult_TransferFailed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transaction_Result_contractResult)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transaction_Result_contractResult_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transaction_Result_contractResult_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transaction_Result_contractResult_Default:
    case Transaction_Result_contractResult_Success:
    case Transaction_Result_contractResult_Revert:
    case Transaction_Result_contractResult_BadJumpDestination:
    case Transaction_Result_contractResult_OutOfMemory:
    case Transaction_Result_contractResult_PrecompiledContract:
    case Transaction_Result_contractResult_StackTooSmall:
    case Transaction_Result_contractResult_StackTooLarge:
    case Transaction_Result_contractResult_IllegalOperation:
    case Transaction_Result_contractResult_StackOverflow:
    case Transaction_Result_contractResult_OutOfEnergy:
    case Transaction_Result_contractResult_OutOfTime:
    case Transaction_Result_contractResult_JvmStackOverFlow:
    case Transaction_Result_contractResult_Unknown:
    case Transaction_Result_contractResult_TransferFailed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Transaction_raw

@implementation Transaction_raw

@dynamic refBlockBytes;
@dynamic refBlockNum;
@dynamic refBlockHash;
@dynamic expiration;
@dynamic authsArray, authsArray_Count;
@dynamic data_p;
@dynamic contractArray, contractArray_Count;
@dynamic scripts;
@dynamic timestamp;
@dynamic feeLimit;

typedef struct Transaction_raw__storage_ {
  uint32_t _has_storage_[1];
  NSData *refBlockBytes;
  NSData *refBlockHash;
  NSMutableArray *authsArray;
  NSData *data_p;
  NSMutableArray *contractArray;
  NSData *scripts;
  int64_t refBlockNum;
  int64_t expiration;
  int64_t timestamp;
  int64_t feeLimit;
} Transaction_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "refBlockBytes",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockBytes,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockBytes),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "refBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "refBlockHash",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_RefBlockHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, refBlockHash),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "expiration",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Expiration,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, expiration),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "authsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(authority),
        .number = Transaction_raw_FieldNumber_AuthsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, authsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Data_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction_Contract),
        .number = Transaction_raw_FieldNumber_ContractArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, contractArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "scripts",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Scripts,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, scripts),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_Timestamp,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "feeLimit",
        .dataTypeSpecific.className = NULL,
        .number = Transaction_raw_FieldNumber_FeeLimit,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(Transaction_raw__storage_, feeLimit),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transaction_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transaction_raw__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(Transaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionInfo

@implementation TransactionInfo

@dynamic id_p;
@dynamic fee;
@dynamic blockNumber;
@dynamic blockTimeStamp;
@dynamic contractResultArray, contractResultArray_Count;
@dynamic contractAddress;
@dynamic hasReceipt, receipt;
@dynamic logArray, logArray_Count;
@dynamic result;
@dynamic resMessage;
@dynamic assetIssueId;
@dynamic withdrawAmount;
@dynamic unfreezeAmount;
@dynamic internalTransactionsArray, internalTransactionsArray_Count;
@dynamic exchangeReceivedAmount;
@dynamic exchangeInjectAnotherAmount;
@dynamic exchangeWithdrawAnotherAmount;
@dynamic exchangeId;
@dynamic shieldedTransactionFee;

typedef struct TransactionInfo__storage_ {
  uint32_t _has_storage_[1];
  TransactionInfo_code result;
  NSData *id_p;
  NSMutableArray *contractResultArray;
  NSData *contractAddress;
  ResourceReceipt *receipt;
  NSMutableArray *logArray;
  NSData *resMessage;
  NSString *assetIssueId;
  NSMutableArray *internalTransactionsArray;
  int64_t fee;
  int64_t blockNumber;
  int64_t blockTimeStamp;
  int64_t withdrawAmount;
  int64_t unfreezeAmount;
  int64_t exchangeReceivedAmount;
  int64_t exchangeInjectAnotherAmount;
  int64_t exchangeWithdrawAnotherAmount;
  int64_t exchangeId;
  int64_t shieldedTransactionFee;
} TransactionInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_Fee,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_BlockNumber,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, blockNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockTimeStamp",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_BlockTimeStamp,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, blockTimeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "contractResultArray",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ContractResultArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, contractResultArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "contractAddress",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ContractAddress,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, contractAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "receipt",
        .dataTypeSpecific.className = GPBStringifySymbol(ResourceReceipt),
        .number = TransactionInfo_FieldNumber_Receipt,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, receipt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "logArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionInfo_Log),
        .number = TransactionInfo_FieldNumber_LogArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, logArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "result",
        .dataTypeSpecific.enumDescFunc = TransactionInfo_code_EnumDescriptor,
        .number = TransactionInfo_FieldNumber_Result,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, result),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "resMessage",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ResMessage,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, resMessage),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "assetIssueId",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_AssetIssueId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, assetIssueId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "withdrawAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_WithdrawAmount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, withdrawAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "unfreezeAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_UnfreezeAmount,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, unfreezeAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "internalTransactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InternalTransaction),
        .number = TransactionInfo_FieldNumber_InternalTransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, internalTransactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "exchangeReceivedAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ExchangeReceivedAmount,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeReceivedAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeInjectAnotherAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ExchangeInjectAnotherAmount,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeInjectAnotherAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeWithdrawAnotherAmount",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ExchangeWithdrawAnotherAmount,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeWithdrawAnotherAmount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "exchangeId",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ExchangeId,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, exchangeId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "shieldedTransactionFee",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_FieldNumber_ShieldedTransactionFee,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(TransactionInfo__storage_, shieldedTransactionFee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\003\013\000\004\016\000\005\000contractResult\000\n\n\000\016\013A\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t TransactionInfo_Result_RawValue(TransactionInfo *message) {
  GPBDescriptor *descriptor = [TransactionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionInfo_FieldNumber_Result];
  return GPBGetMessageInt32Field(message, field);
}

void SetTransactionInfo_Result_RawValue(TransactionInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [TransactionInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:TransactionInfo_FieldNumber_Result];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum TransactionInfo_code

GPBEnumDescriptor *TransactionInfo_code_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Sucess\000Failed\000";
    static const int32_t values[] = {
        TransactionInfo_code_Sucess,
        TransactionInfo_code_Failed,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(TransactionInfo_code)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:TransactionInfo_code_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL TransactionInfo_code_IsValidValue(int32_t value__) {
  switch (value__) {
    case TransactionInfo_code_Sucess:
    case TransactionInfo_code_Failed:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - TransactionInfo_Log

@implementation TransactionInfo_Log

@dynamic address;
@dynamic topicsArray, topicsArray_Count;
@dynamic data_p;

typedef struct TransactionInfo_Log__storage_ {
  uint32_t _has_storage_[1];
  NSData *address;
  NSMutableArray *topicsArray;
  NSData *data_p;
} TransactionInfo_Log__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "address",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_Log_FieldNumber_Address,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, address),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "topicsArray",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_Log_FieldNumber_TopicsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, topicsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = TransactionInfo_Log_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionInfo_Log__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionInfo_Log class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionInfo_Log__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(TransactionInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionRet

@implementation TransactionRet

@dynamic blockNumber;
@dynamic blockTimeStamp;
@dynamic transactioninfoArray, transactioninfoArray_Count;

typedef struct TransactionRet__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactioninfoArray;
  int64_t blockNumber;
  int64_t blockTimeStamp;
} TransactionRet__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "blockNumber",
        .dataTypeSpecific.className = NULL,
        .number = TransactionRet_FieldNumber_BlockNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionRet__storage_, blockNumber),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockTimeStamp",
        .dataTypeSpecific.className = NULL,
        .number = TransactionRet_FieldNumber_BlockTimeStamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionRet__storage_, blockTimeStamp),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "transactioninfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(TransactionInfo),
        .number = TransactionRet_FieldNumber_TransactioninfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(TransactionRet__storage_, transactioninfoArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionRet class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionRet__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\013\000\002\016\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Transactions

@implementation Transactions

@dynamic transactionsArray, transactionsArray_Count;

typedef struct Transactions__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
} Transactions__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Transactions_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Transactions__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Transactions class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Transactions__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - TransactionSign

@implementation TransactionSign

@dynamic hasTransaction, transaction;
@dynamic privateKey;

typedef struct TransactionSign__storage_ {
  uint32_t _has_storage_[1];
  Transaction *transaction;
  NSData *privateKey;
} TransactionSign__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transaction",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = TransactionSign_FieldNumber_Transaction,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(TransactionSign__storage_, transaction),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "privateKey",
        .dataTypeSpecific.className = NULL,
        .number = TransactionSign_FieldNumber_PrivateKey,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(TransactionSign__storage_, privateKey),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[TransactionSign class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(TransactionSign__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader

@implementation BlockHeader

@dynamic hasRawData, rawData;
@dynamic witnessSignature;

typedef struct BlockHeader__storage_ {
  uint32_t _has_storage_[1];
  BlockHeader_raw *rawData;
  NSData *witnessSignature;
} BlockHeader__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rawData",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader_raw),
        .number = BlockHeader_FieldNumber_RawData,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, rawData),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "witnessSignature",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_FieldNumber_WitnessSignature,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader__storage_, witnessSignature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockHeader_raw

@implementation BlockHeader_raw

@dynamic timestamp;
@dynamic txTrieRoot;
@dynamic parentHash;
@dynamic number;
@dynamic witnessId;
@dynamic witnessAddress;
@dynamic version;
@dynamic accountStateRoot;

typedef struct BlockHeader_raw__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  NSData *txTrieRoot;
  NSData *parentHash;
  NSData *witnessAddress;
  NSData *accountStateRoot;
  int64_t timestamp;
  int64_t number;
  int64_t witnessId;
} BlockHeader_raw__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Timestamp,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "txTrieRoot",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_TxTrieRoot,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, txTrieRoot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "parentHash",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_ParentHash,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, parentHash),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Number,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "witnessId",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_WitnessId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "witnessAddress",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_WitnessAddress,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, witnessAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_Version,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "accountStateRoot",
        .dataTypeSpecific.className = NULL,
        .number = BlockHeader_raw_FieldNumber_AccountStateRoot,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(BlockHeader_raw__storage_, accountStateRoot),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockHeader_raw class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockHeader_raw__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\002\n\000\003\n\000\013\020\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BlockHeader)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Block

@implementation Block

@dynamic transactionsArray, transactionsArray_Count;
@dynamic hasBlockHeader, blockHeader;

typedef struct Block__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *transactionsArray;
  BlockHeader *blockHeader;
} Block__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Block_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Block__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeader",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Block_FieldNumber_BlockHeader,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Block__storage_, blockHeader),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Block class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Block__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainInventory

@implementation ChainInventory

@dynamic idsArray, idsArray_Count;
@dynamic remainNum;

typedef struct ChainInventory__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *idsArray;
  int64_t remainNum;
} ChainInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(ChainInventory_BlockId),
        .number = ChainInventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(ChainInventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "remainNum",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_FieldNumber_RemainNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainInventory__storage_, remainNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainInventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ChainInventory_BlockId

@implementation ChainInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct ChainInventory_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} ChainInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = ChainInventory_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ChainInventory_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ChainInventory_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ChainInventory_BlockId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ChainInventory)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - BlockInventory

@implementation BlockInventory

@dynamic idsArray, idsArray_Count;
@dynamic type;

typedef struct BlockInventory__storage_ {
  uint32_t _has_storage_[1];
  BlockInventory_Type type;
  NSMutableArray *idsArray;
} BlockInventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "idsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockInventory_BlockId),
        .number = BlockInventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(BlockInventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = BlockInventory_Type_EnumDescriptor,
        .number = BlockInventory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInventory__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t BlockInventory_Type_RawValue(BlockInventory *message) {
  GPBDescriptor *descriptor = [BlockInventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetBlockInventory_Type_RawValue(BlockInventory *message, int32_t value) {
  GPBDescriptor *descriptor = [BlockInventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:BlockInventory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum BlockInventory_Type

GPBEnumDescriptor *BlockInventory_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Sync\000Advtise\000Fetch\000";
    static const int32_t values[] = {
        BlockInventory_Type_Sync,
        BlockInventory_Type_Advtise,
        BlockInventory_Type_Fetch,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(BlockInventory_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:BlockInventory_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL BlockInventory_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case BlockInventory_Type_Sync:
    case BlockInventory_Type_Advtise:
    case BlockInventory_Type_Fetch:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - BlockInventory_BlockId

@implementation BlockInventory_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct BlockInventory_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} BlockInventory_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = BlockInventory_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = BlockInventory_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(BlockInventory_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[BlockInventory_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(BlockInventory_BlockId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(BlockInventory)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - Inventory

@implementation Inventory

@dynamic type;
@dynamic idsArray, idsArray_Count;

typedef struct Inventory__storage_ {
  uint32_t _has_storage_[1];
  Inventory_InventoryType type;
  NSMutableArray *idsArray;
} Inventory__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Inventory_InventoryType_EnumDescriptor,
        .number = Inventory_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Inventory__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "idsArray",
        .dataTypeSpecific.className = NULL,
        .number = Inventory_FieldNumber_IdsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Inventory__storage_, idsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Inventory class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Inventory__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Inventory_Type_RawValue(Inventory *message) {
  GPBDescriptor *descriptor = [Inventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetInventory_Type_RawValue(Inventory *message, int32_t value) {
  GPBDescriptor *descriptor = [Inventory descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Inventory_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Inventory_InventoryType

GPBEnumDescriptor *Inventory_InventoryType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Trx\000Block\000";
    static const int32_t values[] = {
        Inventory_InventoryType_Trx,
        Inventory_InventoryType_Block,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Inventory_InventoryType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Inventory_InventoryType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Inventory_InventoryType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Inventory_InventoryType_Trx:
    case Inventory_InventoryType_Block:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Items

@implementation Items

@dynamic type;
@dynamic blocksArray, blocksArray_Count;
@dynamic blockHeadersArray, blockHeadersArray_Count;
@dynamic transactionsArray, transactionsArray_Count;

typedef struct Items__storage_ {
  uint32_t _has_storage_[1];
  Items_ItemType type;
  NSMutableArray *blocksArray;
  NSMutableArray *blockHeadersArray;
  NSMutableArray *transactionsArray;
} Items__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = Items_ItemType_EnumDescriptor,
        .number = Items_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Items__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "blocksArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Block),
        .number = Items_FieldNumber_BlocksArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, blocksArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "blockHeadersArray",
        .dataTypeSpecific.className = GPBStringifySymbol(BlockHeader),
        .number = Items_FieldNumber_BlockHeadersArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, blockHeadersArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "transactionsArray",
        .dataTypeSpecific.className = GPBStringifySymbol(Transaction),
        .number = Items_FieldNumber_TransactionsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(Items__storage_, transactionsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Items class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Items__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Items_Type_RawValue(Items *message) {
  GPBDescriptor *descriptor = [Items descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetItems_Type_RawValue(Items *message, int32_t value) {
  GPBDescriptor *descriptor = [Items descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Items_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum Items_ItemType

GPBEnumDescriptor *Items_ItemType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Err\000Trx\000Block\000Blockheader\000";
    static const int32_t values[] = {
        Items_ItemType_Err,
        Items_ItemType_Trx,
        Items_ItemType_Block,
        Items_ItemType_Blockheader,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Items_ItemType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Items_ItemType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Items_ItemType_IsValidValue(int32_t value__) {
  switch (value__) {
    case Items_ItemType_Err:
    case Items_ItemType_Trx:
    case Items_ItemType_Block:
    case Items_ItemType_Blockheader:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - DynamicProperties

@implementation DynamicProperties

@dynamic lastSolidityBlockNum;

typedef struct DynamicProperties__storage_ {
  uint32_t _has_storage_[1];
  int64_t lastSolidityBlockNum;
} DynamicProperties__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastSolidityBlockNum",
        .dataTypeSpecific.className = NULL,
        .number = DynamicProperties_FieldNumber_LastSolidityBlockNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DynamicProperties__storage_, lastSolidityBlockNum),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DynamicProperties class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DynamicProperties__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DisconnectMessage

@implementation DisconnectMessage

@dynamic reason;

typedef struct DisconnectMessage__storage_ {
  uint32_t _has_storage_[1];
  ReasonCode reason;
} DisconnectMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "reason",
        .dataTypeSpecific.enumDescFunc = ReasonCode_EnumDescriptor,
        .number = DisconnectMessage_FieldNumber_Reason,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DisconnectMessage__storage_, reason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DisconnectMessage class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DisconnectMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DisconnectMessage_Reason_RawValue(DisconnectMessage *message) {
  GPBDescriptor *descriptor = [DisconnectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
  return GPBGetMessageInt32Field(message, field);
}

void SetDisconnectMessage_Reason_RawValue(DisconnectMessage *message, int32_t value) {
  GPBDescriptor *descriptor = [DisconnectMessage descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DisconnectMessage_FieldNumber_Reason];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - HelloMessage

@implementation HelloMessage

@dynamic hasFrom, from;
@dynamic version;
@dynamic timestamp;
@dynamic hasGenesisBlockId, genesisBlockId;
@dynamic hasSolidBlockId, solidBlockId;
@dynamic hasHeadBlockId, headBlockId;

typedef struct HelloMessage__storage_ {
  uint32_t _has_storage_[1];
  int32_t version;
  Endpoint *from;
  HelloMessage_BlockId *genesisBlockId;
  HelloMessage_BlockId *solidBlockId;
  HelloMessage_BlockId *headBlockId;
  int64_t timestamp;
} HelloMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "from",
        .dataTypeSpecific.className = GPBStringifySymbol(Endpoint),
        .number = HelloMessage_FieldNumber_From,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, from),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "version",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_FieldNumber_Version,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, version),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_FieldNumber_Timestamp,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "genesisBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_GenesisBlockId,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, genesisBlockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "solidBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_SolidBlockId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, solidBlockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "headBlockId",
        .dataTypeSpecific.className = GPBStringifySymbol(HelloMessage_BlockId),
        .number = HelloMessage_FieldNumber_HeadBlockId,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(HelloMessage__storage_, headBlockId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloMessage class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\004\016\000\005\014\000\006\013\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - HelloMessage_BlockId

@implementation HelloMessage_BlockId

@dynamic hash_p;
@dynamic number;

typedef struct HelloMessage_BlockId__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  int64_t number;
} HelloMessage_BlockId__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_BlockId_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "number",
        .dataTypeSpecific.className = NULL,
        .number = HelloMessage_BlockId_FieldNumber_Number,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(HelloMessage_BlockId__storage_, number),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[HelloMessage_BlockId class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(HelloMessage_BlockId__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(HelloMessage)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InternalTransaction

@implementation InternalTransaction

@dynamic hash_p;
@dynamic callerAddress;
@dynamic transferToAddress;
@dynamic callValueInfoArray, callValueInfoArray_Count;
@dynamic note;
@dynamic rejected;

typedef struct InternalTransaction__storage_ {
  uint32_t _has_storage_[1];
  NSData *hash_p;
  NSData *callerAddress;
  NSData *transferToAddress;
  NSMutableArray *callValueInfoArray;
  NSData *note;
} InternalTransaction__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "hash_p",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_FieldNumber_Hash_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InternalTransaction__storage_, hash_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "callerAddress",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_FieldNumber_CallerAddress,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InternalTransaction__storage_, callerAddress),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "transferToAddress",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_FieldNumber_TransferToAddress,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(InternalTransaction__storage_, transferToAddress),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "callValueInfoArray",
        .dataTypeSpecific.className = GPBStringifySymbol(InternalTransaction_CallValueInfo),
        .number = InternalTransaction_FieldNumber_CallValueInfoArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(InternalTransaction__storage_, callValueInfoArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "note",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_FieldNumber_Note,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(InternalTransaction__storage_, note),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "rejected",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_FieldNumber_Rejected,
        .hasIndex = 4,
        .offset = 5,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InternalTransaction class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InternalTransaction__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\003\n\247\000\004\000callValueInfo\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - InternalTransaction_CallValueInfo

@implementation InternalTransaction_CallValueInfo

@dynamic callValue;
@dynamic tokenId;

typedef struct InternalTransaction_CallValueInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *tokenId;
  int64_t callValue;
} InternalTransaction_CallValueInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "callValue",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_CallValueInfo_FieldNumber_CallValue,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(InternalTransaction_CallValueInfo__storage_, callValue),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "tokenId",
        .dataTypeSpecific.className = NULL,
        .number = InternalTransaction_CallValueInfo_FieldNumber_TokenId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(InternalTransaction_CallValueInfo__storage_, tokenId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[InternalTransaction_CallValueInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(InternalTransaction_CallValueInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\t\000\002\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(InternalTransaction)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - DelegatedResourceAccountIndex

@implementation DelegatedResourceAccountIndex

@dynamic account;
@dynamic fromAccountsArray, fromAccountsArray_Count;
@dynamic toAccountsArray, toAccountsArray_Count;

typedef struct DelegatedResourceAccountIndex__storage_ {
  uint32_t _has_storage_[1];
  NSData *account;
  NSMutableArray *fromAccountsArray;
  NSMutableArray *toAccountsArray;
} DelegatedResourceAccountIndex__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResourceAccountIndex_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "fromAccountsArray",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResourceAccountIndex_FieldNumber_FromAccountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, fromAccountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
      {
        .name = "toAccountsArray",
        .dataTypeSpecific.className = NULL,
        .number = DelegatedResourceAccountIndex_FieldNumber_ToAccountsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DelegatedResourceAccountIndex__storage_, toAccountsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DelegatedResourceAccountIndex class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DelegatedResourceAccountIndex__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\002\000fromAccounts\000\003\000toAccounts\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo

@implementation NodeInfo

@dynamic beginSyncNum;
@dynamic block;
@dynamic solidityBlock;
@dynamic currentConnectCount;
@dynamic activeConnectCount;
@dynamic passiveConnectCount;
@dynamic totalFlow;
@dynamic peerInfoListArray, peerInfoListArray_Count;
@dynamic hasConfigNodeInfo, configNodeInfo;
@dynamic hasMachineInfo, machineInfo;
@dynamic cheatWitnessInfoMap, cheatWitnessInfoMap_Count;

typedef struct NodeInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t currentConnectCount;
  int32_t activeConnectCount;
  int32_t passiveConnectCount;
  NSString *block;
  NSString *solidityBlock;
  NSMutableArray *peerInfoListArray;
  NodeInfo_ConfigNodeInfo *configNodeInfo;
  NodeInfo_MachineInfo *machineInfo;
  NSMutableDictionary *cheatWitnessInfoMap;
  int64_t beginSyncNum;
  int64_t totalFlow;
} NodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "beginSyncNum",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_BeginSyncNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, beginSyncNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "block",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_Block,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, block),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "solidityBlock",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_SolidityBlock,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, solidityBlock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "currentConnectCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_CurrentConnectCount,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, currentConnectCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "activeConnectCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_ActiveConnectCount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, activeConnectCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "passiveConnectCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_PassiveConnectCount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, passiveConnectCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalFlow",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_TotalFlow,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, totalFlow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "peerInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo_PeerInfo),
        .number = NodeInfo_FieldNumber_PeerInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, peerInfoListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "configNodeInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo_ConfigNodeInfo),
        .number = NodeInfo_FieldNumber_ConfigNodeInfo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, configNodeInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "machineInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo_MachineInfo),
        .number = NodeInfo_FieldNumber_MachineInfo,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, machineInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "cheatWitnessInfoMap",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_FieldNumber_CheatWitnessInfoMap,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeInfo__storage_, cheatWitnessInfoMap),
        .flags = (GPBFieldFlags)(GPBFieldMapKeyString | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\n\001\014\000\003\r\000\004\023\000\005\022\000\006\023\000\007\t\000\010\000peerInfoList\000\t\016\000\n\013\000"
        "\013\023\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo_PeerInfo

@implementation NodeInfo_PeerInfo

@dynamic lastSyncBlock;
@dynamic remainNum;
@dynamic lastBlockUpdateTime;
@dynamic syncFlag;
@dynamic headBlockTimeWeBothHave;
@dynamic needSyncFromPeer;
@dynamic needSyncFromUs;
@dynamic host;
@dynamic port;
@dynamic nodeId;
@dynamic connectTime;
@dynamic avgLatency;
@dynamic syncToFetchSize;
@dynamic syncToFetchSizePeekNum;
@dynamic syncBlockRequestedSize;
@dynamic unFetchSynNum;
@dynamic blockInPorcSize;
@dynamic headBlockWeBothHave;
@dynamic isActive;
@dynamic score;
@dynamic nodeCount;
@dynamic inFlow;
@dynamic disconnectTimes;
@dynamic localDisconnectReason;
@dynamic remoteDisconnectReason;

typedef struct NodeInfo_PeerInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t port;
  int32_t syncToFetchSize;
  int32_t syncBlockRequestedSize;
  int32_t blockInPorcSize;
  int32_t score;
  int32_t nodeCount;
  int32_t disconnectTimes;
  NSString *lastSyncBlock;
  NSString *host;
  NSString *nodeId;
  NSString *headBlockWeBothHave;
  NSString *localDisconnectReason;
  NSString *remoteDisconnectReason;
  int64_t remainNum;
  int64_t lastBlockUpdateTime;
  int64_t headBlockTimeWeBothHave;
  int64_t connectTime;
  double avgLatency;
  int64_t syncToFetchSizePeekNum;
  int64_t unFetchSynNum;
  int64_t inFlow;
} NodeInfo_PeerInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "lastSyncBlock",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_LastSyncBlock,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, lastSyncBlock),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remainNum",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_RemainNum,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, remainNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "lastBlockUpdateTime",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_LastBlockUpdateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, lastBlockUpdateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "syncFlag",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_SyncFlag,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "headBlockTimeWeBothHave",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_HeadBlockTimeWeBothHave,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, headBlockTimeWeBothHave),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "needSyncFromPeer",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_NeedSyncFromPeer,
        .hasIndex = 6,
        .offset = 7,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "needSyncFromUs",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_NeedSyncFromUs,
        .hasIndex = 8,
        .offset = 9,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "host",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_Host,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, host),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "port",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_Port,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, port),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nodeId",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_NodeId,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, nodeId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "connectTime",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_ConnectTime,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, connectTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "avgLatency",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_AvgLatency,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, avgLatency),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "syncToFetchSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_SyncToFetchSize,
        .hasIndex = 15,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, syncToFetchSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "syncToFetchSizePeekNum",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_SyncToFetchSizePeekNum,
        .hasIndex = 16,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, syncToFetchSizePeekNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "syncBlockRequestedSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_SyncBlockRequestedSize,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, syncBlockRequestedSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "unFetchSynNum",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_UnFetchSynNum,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, unFetchSynNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "blockInPorcSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_BlockInPorcSize,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, blockInPorcSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "headBlockWeBothHave",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_HeadBlockWeBothHave,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, headBlockWeBothHave),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "isActive",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_IsActive,
        .hasIndex = 21,
        .offset = 22,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "score",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_Score,
        .hasIndex = 23,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, score),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "nodeCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_NodeCount,
        .hasIndex = 24,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, nodeCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "inFlow",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_InFlow,
        .hasIndex = 25,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, inFlow),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "disconnectTimes",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_DisconnectTimes,
        .hasIndex = 26,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, disconnectTimes),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "localDisconnectReason",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_LocalDisconnectReason,
        .hasIndex = 27,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, localDisconnectReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "remoteDisconnectReason",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_PeerInfo_FieldNumber_RemoteDisconnectReason,
        .hasIndex = 28,
        .offset = (uint32_t)offsetof(NodeInfo_PeerInfo__storage_, remoteDisconnectReason),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo_PeerInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_PeerInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\026\001\r\000\002\t\000\003\023\000\004\010\000\005\027\000\006\020\000\007\016\000\n\006\000\013\013\000\014\n\000\r\017\000\016\026\000\017\026\000"
        "\020\r\000\021\017\000\022\023\000\023\010\000\025\t\000\026\006\000\027\017\000\030\025\000\031\026\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NodeInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo_ConfigNodeInfo

@implementation NodeInfo_ConfigNodeInfo

@dynamic codeVersion;
@dynamic p2PVersion;
@dynamic listenPort;
@dynamic discoverEnable;
@dynamic activeNodeSize;
@dynamic passiveNodeSize;
@dynamic sendNodeSize;
@dynamic maxConnectCount;
@dynamic sameIpMaxConnectCount;
@dynamic backupListenPort;
@dynamic backupMemberSize;
@dynamic backupPriority;
@dynamic dbVersion;
@dynamic minParticipationRate;
@dynamic supportConstant;
@dynamic minTimeRatio;
@dynamic maxTimeRatio;
@dynamic allowCreationOfContracts;
@dynamic allowAdaptiveEnergy;

typedef struct NodeInfo_ConfigNodeInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t listenPort;
  int32_t activeNodeSize;
  int32_t passiveNodeSize;
  int32_t sendNodeSize;
  int32_t maxConnectCount;
  int32_t sameIpMaxConnectCount;
  int32_t backupListenPort;
  int32_t backupMemberSize;
  int32_t backupPriority;
  int32_t dbVersion;
  int32_t minParticipationRate;
  NSString *codeVersion;
  NSString *p2PVersion;
  double minTimeRatio;
  double maxTimeRatio;
  int64_t allowCreationOfContracts;
  int64_t allowAdaptiveEnergy;
} NodeInfo_ConfigNodeInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "codeVersion",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_CodeVersion,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, codeVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "p2PVersion",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_P2PVersion,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, p2PVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "listenPort",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_ListenPort,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, listenPort),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "discoverEnable",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_DiscoverEnable,
        .hasIndex = 3,
        .offset = 4,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "activeNodeSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_ActiveNodeSize,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, activeNodeSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "passiveNodeSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_PassiveNodeSize,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, passiveNodeSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sendNodeSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_SendNodeSize,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, sendNodeSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "maxConnectCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_MaxConnectCount,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, maxConnectCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "sameIpMaxConnectCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_SameIpMaxConnectCount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, sameIpMaxConnectCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backupListenPort",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_BackupListenPort,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, backupListenPort),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backupMemberSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_BackupMemberSize,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, backupMemberSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "backupPriority",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_BackupPriority,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, backupPriority),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "dbVersion",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_DbVersion,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, dbVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "minParticipationRate",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_MinParticipationRate,
        .hasIndex = 14,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, minParticipationRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "supportConstant",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_SupportConstant,
        .hasIndex = 15,
        .offset = 16,  // Stored in _has_storage_ to save space.
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "minTimeRatio",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_MinTimeRatio,
        .hasIndex = 17,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, minTimeRatio),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "maxTimeRatio",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_MaxTimeRatio,
        .hasIndex = 18,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, maxTimeRatio),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "allowCreationOfContracts",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_AllowCreationOfContracts,
        .hasIndex = 19,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, allowCreationOfContracts),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "allowAdaptiveEnergy",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_ConfigNodeInfo_FieldNumber_AllowAdaptiveEnergy,
        .hasIndex = 20,
        .offset = (uint32_t)offsetof(NodeInfo_ConfigNodeInfo__storage_, allowAdaptiveEnergy),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo_ConfigNodeInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_ConfigNodeInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\023\001\013\000\002\002(\000\003\n\000\004\016\000\005\016\000\006\017\000\007\014\000\010\017\000\t\025\000\n\020\000\013\020\000\014\016\000\r\t"
        "\000\016\024\000\017\017\000\020\014\000\021\014\000\022\030\000\023\023\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NodeInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo_MachineInfo

@implementation NodeInfo_MachineInfo

@dynamic threadCount;
@dynamic deadLockThreadCount;
@dynamic cpuCount;
@dynamic totalMemory;
@dynamic freeMemory;
@dynamic cpuRate;
@dynamic javaVersion;
@dynamic osName;
@dynamic jvmTotalMemoery;
@dynamic jvmFreeMemory;
@dynamic processCpuRate;
@dynamic memoryDescInfoListArray, memoryDescInfoListArray_Count;
@dynamic deadLockThreadInfoListArray, deadLockThreadInfoListArray_Count;

typedef struct NodeInfo_MachineInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t threadCount;
  int32_t deadLockThreadCount;
  int32_t cpuCount;
  NSString *javaVersion;
  NSString *osName;
  NSMutableArray *memoryDescInfoListArray;
  NSMutableArray *deadLockThreadInfoListArray;
  int64_t totalMemory;
  int64_t freeMemory;
  double cpuRate;
  int64_t jvmTotalMemoery;
  int64_t jvmFreeMemory;
  double processCpuRate;
} NodeInfo_MachineInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "threadCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_ThreadCount,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, threadCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "deadLockThreadCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_DeadLockThreadCount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, deadLockThreadCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "cpuCount",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_CpuCount,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, cpuCount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "totalMemory",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_TotalMemory,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, totalMemory),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "freeMemory",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_FreeMemory,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, freeMemory),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "cpuRate",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_CpuRate,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, cpuRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "javaVersion",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_JavaVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, javaVersion),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "osName",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_OsName,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, osName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "jvmTotalMemoery",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_JvmTotalMemoery,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, jvmTotalMemoery),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "jvmFreeMemory",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_JvmFreeMemory,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, jvmFreeMemory),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "processCpuRate",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_FieldNumber_ProcessCpuRate,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, processCpuRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
      {
        .name = "memoryDescInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo_MachineInfo_MemoryDescInfo),
        .number = NodeInfo_MachineInfo_FieldNumber_MemoryDescInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, memoryDescInfoListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deadLockThreadInfoListArray",
        .dataTypeSpecific.className = GPBStringifySymbol(NodeInfo_MachineInfo_DeadLockThreadInfo),
        .number = NodeInfo_MachineInfo_FieldNumber_DeadLockThreadInfoListArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo__storage_, deadLockThreadInfoListArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo_MachineInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_MachineInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\r\001\013\000\002\023\000\003\010\000\004\013\000\005\n\000\006\007\000\007\013\000\010\006\000\t\017\000\n\r\000\013\016\000\014\000memo"
        "ryDescInfoList\000\r\000deadLockThreadInfoList\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NodeInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo_MachineInfo_MemoryDescInfo

@implementation NodeInfo_MachineInfo_MemoryDescInfo

@dynamic name;
@dynamic initSize;
@dynamic useSize;
@dynamic maxSize;
@dynamic useRate;

typedef struct NodeInfo_MachineInfo_MemoryDescInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  int64_t initSize;
  int64_t useSize;
  int64_t maxSize;
  double useRate;
} NodeInfo_MachineInfo_MemoryDescInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_InitSize,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, initSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "useSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_UseSize,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, useSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "maxSize",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_MaxSize,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, maxSize),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "useRate",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_MemoryDescInfo_FieldNumber_UseRate,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_MemoryDescInfo__storage_, useRate),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeDouble,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo_MachineInfo_MemoryDescInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_MachineInfo_MemoryDescInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\010\000\003\007\000\004\007\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NodeInfo_MachineInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NodeInfo_MachineInfo_DeadLockThreadInfo

@implementation NodeInfo_MachineInfo_DeadLockThreadInfo

@dynamic name;
@dynamic lockName;
@dynamic lockOwner;
@dynamic state;
@dynamic blockTime;
@dynamic waitTime;
@dynamic stackTrace;

typedef struct NodeInfo_MachineInfo_DeadLockThreadInfo__storage_ {
  uint32_t _has_storage_[1];
  NSString *name;
  NSString *lockName;
  NSString *lockOwner;
  NSString *state;
  NSString *stackTrace;
  int64_t blockTime;
  int64_t waitTime;
} NodeInfo_MachineInfo_DeadLockThreadInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_Name,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lockName",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_LockName,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, lockName),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lockOwner",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_LockOwner,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, lockOwner),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_State,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "blockTime",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_BlockTime,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, blockTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "waitTime",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_WaitTime,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, waitTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "stackTrace",
        .dataTypeSpecific.className = NULL,
        .number = NodeInfo_MachineInfo_DeadLockThreadInfo_FieldNumber_StackTrace,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_, stackTrace),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NodeInfo_MachineInfo_DeadLockThreadInfo class]
                                     rootClass:[TronRoot class]
                                          file:TronRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NodeInfo_MachineInfo_DeadLockThreadInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\002\010\000\003\t\000\005\t\000\006\010\000\007\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(NodeInfo_MachineInfo)];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
