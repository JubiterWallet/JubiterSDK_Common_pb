// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Jub_Ripple.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "JubRipple.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - RippleProtosJubRippleRoot

@implementation RippleProtosJubRippleRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - RippleProtosJubRippleRoot_FileDescriptor

static GPBFileDescriptor *RippleProtosJubRippleRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"JUB.Proto.Ripple"
                                                 objcPrefix:@"RippleProtos"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum RippleProtosENUM_XRP_TX_TYPE

GPBEnumDescriptor *RippleProtosENUM_XRP_TX_TYPE_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Pymt\000";
    static const int32_t values[] = {
        RippleProtosENUM_XRP_TX_TYPE_Pymt,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RippleProtosENUM_XRP_TX_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RippleProtosENUM_XRP_TX_TYPE_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RippleProtosENUM_XRP_TX_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case RippleProtosENUM_XRP_TX_TYPE_Pymt:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum RippleProtosENUM_XRP_PYMT_TYPE

GPBEnumDescriptor *RippleProtosENUM_XRP_PYMT_TYPE_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Dxrp\000Fx\000Checks\000Escrow\000Prtl\000Chan\000";
    static const int32_t values[] = {
        RippleProtosENUM_XRP_PYMT_TYPE_Dxrp,
        RippleProtosENUM_XRP_PYMT_TYPE_Fx,
        RippleProtosENUM_XRP_PYMT_TYPE_Checks,
        RippleProtosENUM_XRP_PYMT_TYPE_Escrow,
        RippleProtosENUM_XRP_PYMT_TYPE_Prtl,
        RippleProtosENUM_XRP_PYMT_TYPE_Chan,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(RippleProtosENUM_XRP_PYMT_TYPE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:RippleProtosENUM_XRP_PYMT_TYPE_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL RippleProtosENUM_XRP_PYMT_TYPE_IsValidValue(int32_t value__) {
  switch (value__) {
    case RippleProtosENUM_XRP_PYMT_TYPE_Dxrp:
    case RippleProtosENUM_XRP_PYMT_TYPE_Fx:
    case RippleProtosENUM_XRP_PYMT_TYPE_Checks:
    case RippleProtosENUM_XRP_PYMT_TYPE_Escrow:
    case RippleProtosENUM_XRP_PYMT_TYPE_Prtl:
    case RippleProtosENUM_XRP_PYMT_TYPE_Chan:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - RippleProtosPymtAmount

@implementation RippleProtosPymtAmount

@dynamic currency;
@dynamic value;
@dynamic issuer;

typedef struct RippleProtosPymtAmount__storage_ {
  uint32_t _has_storage_[1];
  NSString *currency;
  NSString *value;
  NSString *issuer;
} RippleProtosPymtAmount__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "currency",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosPymtAmount_FieldNumber_Currency,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RippleProtosPymtAmount__storage_, currency),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "value",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosPymtAmount_FieldNumber_Value,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RippleProtosPymtAmount__storage_, value),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "issuer",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosPymtAmount_FieldNumber_Issuer,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RippleProtosPymtAmount__storage_, issuer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RippleProtosPymtAmount class]
                                     rootClass:[RippleProtosJubRippleRoot class]
                                          file:RippleProtosJubRippleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RippleProtosPymtAmount__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RippleProtosXrpMemo

@implementation RippleProtosXrpMemo

@dynamic type;
@dynamic data_p;
@dynamic format;

typedef struct RippleProtosXrpMemo__storage_ {
  uint32_t _has_storage_[1];
  NSString *type;
  NSString *data_p;
  NSString *format;
} RippleProtosXrpMemo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosXrpMemo_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RippleProtosXrpMemo__storage_, type),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "data_p",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosXrpMemo_FieldNumber_Data_p,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RippleProtosXrpMemo__storage_, data_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "format",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosXrpMemo_FieldNumber_Format,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RippleProtosXrpMemo__storage_, format),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RippleProtosXrpMemo class]
                                     rootClass:[RippleProtosJubRippleRoot class]
                                          file:RippleProtosJubRippleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RippleProtosXrpMemo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RippleProtosPymtXRP

@implementation RippleProtosPymtXRP

@dynamic type;
@dynamic hasAmount, amount;
@dynamic destination;
@dynamic destinationTag;
@dynamic invoiceId;
@dynamic hasSendMax, sendMax;
@dynamic hasDeliverMin, deliverMin;

typedef struct RippleProtosPymtXRP__storage_ {
  uint32_t _has_storage_[1];
  RippleProtosENUM_XRP_PYMT_TYPE type;
  RippleProtosPymtAmount *amount;
  NSString *destination;
  NSString *destinationTag;
  NSString *invoiceId;
  RippleProtosPymtAmount *sendMax;
  RippleProtosPymtAmount *deliverMin;
} RippleProtosPymtXRP__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RippleProtosENUM_XRP_PYMT_TYPE_EnumDescriptor,
        .number = RippleProtosPymtXRP_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "amount",
        .dataTypeSpecific.className = GPBStringifySymbol(RippleProtosPymtAmount),
        .number = RippleProtosPymtXRP_FieldNumber_Amount,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, amount),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "destination",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosPymtXRP_FieldNumber_Destination,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, destination),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "destinationTag",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosPymtXRP_FieldNumber_DestinationTag,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, destinationTag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "invoiceId",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosPymtXRP_FieldNumber_InvoiceId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, invoiceId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sendMax",
        .dataTypeSpecific.className = GPBStringifySymbol(RippleProtosPymtAmount),
        .number = RippleProtosPymtXRP_FieldNumber_SendMax,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, sendMax),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deliverMin",
        .dataTypeSpecific.className = GPBStringifySymbol(RippleProtosPymtAmount),
        .number = RippleProtosPymtXRP_FieldNumber_DeliverMin,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RippleProtosPymtXRP__storage_, deliverMin),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RippleProtosPymtXRP class]
                                     rootClass:[RippleProtosJubRippleRoot class]
                                          file:RippleProtosJubRippleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RippleProtosPymtXRP__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RippleProtosPymtXRP_Type_RawValue(RippleProtosPymtXRP *message) {
  GPBDescriptor *descriptor = [RippleProtosPymtXRP descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RippleProtosPymtXRP_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRippleProtosPymtXRP_Type_RawValue(RippleProtosPymtXRP *message, int32_t value) {
  GPBDescriptor *descriptor = [RippleProtosPymtXRP descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RippleProtosPymtXRP_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - RippleProtosTransactionXRP

@implementation RippleProtosTransactionXRP

@dynamic actionOneOfCase;
@dynamic account;
@dynamic type;
@dynamic fee;
@dynamic sequence;
@dynamic accountTxnId;
@dynamic flags;
@dynamic lastLedgerSequence;
@dynamic hasMemo, memo;
@dynamic sourceTag;
@dynamic pymt;

typedef struct RippleProtosTransactionXRP__storage_ {
  uint32_t _has_storage_[2];
  RippleProtosENUM_XRP_TX_TYPE type;
  NSString *account;
  NSString *fee;
  NSString *sequence;
  NSString *accountTxnId;
  NSString *flags;
  NSString *lastLedgerSequence;
  RippleProtosXrpMemo *memo;
  NSString *sourceTag;
  RippleProtosPymtXRP *pymt;
} RippleProtosTransactionXRP__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "account",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_Account,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, account),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = RippleProtosENUM_XRP_TX_TYPE_EnumDescriptor,
        .number = RippleProtosTransactionXRP_FieldNumber_Type,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "fee",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_Fee,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, fee),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sequence",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_Sequence,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, sequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "accountTxnId",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_AccountTxnId,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, accountTxnId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "flags",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_Flags,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, flags),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "lastLedgerSequence",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_LastLedgerSequence,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, lastLedgerSequence),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "memo",
        .dataTypeSpecific.className = GPBStringifySymbol(RippleProtosXrpMemo),
        .number = RippleProtosTransactionXRP_FieldNumber_Memo,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, memo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "sourceTag",
        .dataTypeSpecific.className = NULL,
        .number = RippleProtosTransactionXRP_FieldNumber_SourceTag,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, sourceTag),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pymt",
        .dataTypeSpecific.className = GPBStringifySymbol(RippleProtosPymtXRP),
        .number = RippleProtosTransactionXRP_FieldNumber_Pymt,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(RippleProtosTransactionXRP__storage_, pymt),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RippleProtosTransactionXRP class]
                                     rootClass:[RippleProtosJubRippleRoot class]
                                          file:RippleProtosJubRippleRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RippleProtosTransactionXRP__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "action",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RippleProtosTransactionXRP_Type_RawValue(RippleProtosTransactionXRP *message) {
  GPBDescriptor *descriptor = [RippleProtosTransactionXRP descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RippleProtosTransactionXRP_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRippleProtosTransactionXRP_Type_RawValue(RippleProtosTransactionXRP *message, int32_t value) {
  GPBDescriptor *descriptor = [RippleProtosTransactionXRP descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RippleProtosTransactionXRP_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void RippleProtosTransactionXRP_ClearActionOneOfCase(RippleProtosTransactionXRP *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}

#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
