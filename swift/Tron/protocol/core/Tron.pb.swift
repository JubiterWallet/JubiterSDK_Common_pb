// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: core/Tron.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum Protocol_AccountType: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case normal // = 0
  case assetIssue // = 1
  case contract // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .normal
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .assetIssue
    case 2: self = .contract
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .normal: return 0
    case .assetIssue: return 1
    case .contract: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_AccountType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_AccountType] = [
    .normal,
    .assetIssue,
    .contract,
  ]
}

#endif  // swift(>=4.2)

public enum Protocol_ReasonCode: SwiftProtobuf.Enum {
  public typealias RawValue = Int
  case requested // = 0
  case badProtocol // = 2
  case tooManyPeers // = 4
  case duplicatePeer // = 5
  case incompatibleProtocol // = 6
  case nullIdentity // = 7
  case peerQuiting // = 8
  case unexpectedIdentity // = 9
  case localIdentity // = 10
  case pingTimeout // = 11
  case userReason // = 16
  case reset // = 17
  case syncFail // = 18
  case fetchFail // = 19
  case badTx // = 20
  case badBlock // = 21
  case forked // = 22
  case unlinkable // = 23
  case incompatibleVersion // = 24
  case incompatibleChain // = 25
  case timeOut // = 32
  case connectFail // = 33
  case tooManyPeersWithSameIp // = 34
  case unknown // = 255
  case UNRECOGNIZED(Int)

  public init() {
    self = .requested
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .requested
    case 2: self = .badProtocol
    case 4: self = .tooManyPeers
    case 5: self = .duplicatePeer
    case 6: self = .incompatibleProtocol
    case 7: self = .nullIdentity
    case 8: self = .peerQuiting
    case 9: self = .unexpectedIdentity
    case 10: self = .localIdentity
    case 11: self = .pingTimeout
    case 16: self = .userReason
    case 17: self = .reset
    case 18: self = .syncFail
    case 19: self = .fetchFail
    case 20: self = .badTx
    case 21: self = .badBlock
    case 22: self = .forked
    case 23: self = .unlinkable
    case 24: self = .incompatibleVersion
    case 25: self = .incompatibleChain
    case 32: self = .timeOut
    case 33: self = .connectFail
    case 34: self = .tooManyPeersWithSameIp
    case 255: self = .unknown
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .requested: return 0
    case .badProtocol: return 2
    case .tooManyPeers: return 4
    case .duplicatePeer: return 5
    case .incompatibleProtocol: return 6
    case .nullIdentity: return 7
    case .peerQuiting: return 8
    case .unexpectedIdentity: return 9
    case .localIdentity: return 10
    case .pingTimeout: return 11
    case .userReason: return 16
    case .reset: return 17
    case .syncFail: return 18
    case .fetchFail: return 19
    case .badTx: return 20
    case .badBlock: return 21
    case .forked: return 22
    case .unlinkable: return 23
    case .incompatibleVersion: return 24
    case .incompatibleChain: return 25
    case .timeOut: return 32
    case .connectFail: return 33
    case .tooManyPeersWithSameIp: return 34
    case .unknown: return 255
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Protocol_ReasonCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_ReasonCode] = [
    .requested,
    .badProtocol,
    .tooManyPeers,
    .duplicatePeer,
    .incompatibleProtocol,
    .nullIdentity,
    .peerQuiting,
    .unexpectedIdentity,
    .localIdentity,
    .pingTimeout,
    .userReason,
    .reset,
    .syncFail,
    .fetchFail,
    .badTx,
    .badBlock,
    .forked,
    .unlinkable,
    .incompatibleVersion,
    .incompatibleChain,
    .timeOut,
    .connectFail,
    .tooManyPeersWithSameIp,
    .unknown,
  ]
}

#endif  // swift(>=4.2)

/// AccountId, (name, address) use name, (null, address) use address, (name, null) use name,
public struct Protocol_AccountId {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var name: Data = SwiftProtobuf.Internal.emptyData

  public var address: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// vote message
public struct Protocol_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// the super rep address
  public var voteAddress: Data = SwiftProtobuf.Internal.emptyData

  /// the vote num to this super rep.
  public var voteCount: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Proposal
public struct Protocol_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var proposalID: Int64 = 0

  public var proposerAddress: Data = SwiftProtobuf.Internal.emptyData

  public var parameters: Dictionary<Int64,Int64> = [:]

  public var expirationTime: Int64 = 0

  public var createTime: Int64 = 0

  public var approvals: [Data] = []

  public var state: Protocol_Proposal.State = .pending

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum State: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case pending // = 0
    case disapproved // = 1
    case approved // = 2
    case canceled // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .pending
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .pending
      case 1: self = .disapproved
      case 2: self = .approved
      case 3: self = .canceled
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .pending: return 0
      case .disapproved: return 1
      case .approved: return 2
      case .canceled: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Proposal.State: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Proposal.State] = [
    .pending,
    .disapproved,
    .approved,
    .canceled,
  ]
}

#endif  // swift(>=4.2)

/// Exchange
public struct Protocol_Exchange {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var exchangeID: Int64 = 0

  public var creatorAddress: Data = SwiftProtobuf.Internal.emptyData

  public var createTime: Int64 = 0

  public var firstTokenID: Data = SwiftProtobuf.Internal.emptyData

  public var firstTokenBalance: Int64 = 0

  public var secondTokenID: Data = SwiftProtobuf.Internal.emptyData

  public var secondTokenBalance: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ChainParameters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainParameter: [Protocol_ChainParameters.ChainParameter] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct ChainParameter {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: String = String()

    public var value: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Account 
public struct Protocol_Account {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// account nick name
  public var accountName: Data {
    get {return _storage._accountName}
    set {_uniqueStorage()._accountName = newValue}
  }

  public var type: Protocol_AccountType {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// the create address
  public var address: Data {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  /// the trx balance
  public var balance: Int64 {
    get {return _storage._balance}
    set {_uniqueStorage()._balance = newValue}
  }

  /// the votes
  public var votes: [Protocol_Vote] {
    get {return _storage._votes}
    set {_uniqueStorage()._votes = newValue}
  }

  /// the other asset owned by this account
  public var asset: Dictionary<String,Int64> {
    get {return _storage._asset}
    set {_uniqueStorage()._asset = newValue}
  }

  /// the other asset owned by this accountï¼Œkey is assetId
  public var assetV2: Dictionary<String,Int64> {
    get {return _storage._assetV2}
    set {_uniqueStorage()._assetV2 = newValue}
  }

  /// the frozen balance for bandwidth
  public var frozen: [Protocol_Account.Frozen] {
    get {return _storage._frozen}
    set {_uniqueStorage()._frozen = newValue}
  }

  /// bandwidth, get from frozen
  public var netUsage: Int64 {
    get {return _storage._netUsage}
    set {_uniqueStorage()._netUsage = newValue}
  }

  ///Frozen balance provided by other accounts to this account
  public var acquiredDelegatedFrozenBalanceForBandwidth: Int64 {
    get {return _storage._acquiredDelegatedFrozenBalanceForBandwidth}
    set {_uniqueStorage()._acquiredDelegatedFrozenBalanceForBandwidth = newValue}
  }

  ///Freeze and provide balances to other accounts
  public var delegatedFrozenBalanceForBandwidth: Int64 {
    get {return _storage._delegatedFrozenBalanceForBandwidth}
    set {_uniqueStorage()._delegatedFrozenBalanceForBandwidth = newValue}
  }

  /// this account create time
  public var createTime: Int64 {
    get {return _storage._createTime}
    set {_uniqueStorage()._createTime = newValue}
  }

  /// this last operation time, including transfer, voting and so on. //FIXME fix grammar
  public var latestOprationTime: Int64 {
    get {return _storage._latestOprationTime}
    set {_uniqueStorage()._latestOprationTime = newValue}
  }

  /// witness block producing allowance
  public var allowance: Int64 {
    get {return _storage._allowance}
    set {_uniqueStorage()._allowance = newValue}
  }

  /// last withdraw time
  public var latestWithdrawTime: Int64 {
    get {return _storage._latestWithdrawTime}
    set {_uniqueStorage()._latestWithdrawTime = newValue}
  }

  /// not used so far
  public var code: Data {
    get {return _storage._code}
    set {_uniqueStorage()._code = newValue}
  }

  public var isWitness: Bool {
    get {return _storage._isWitness}
    set {_uniqueStorage()._isWitness = newValue}
  }

  public var isCommittee: Bool {
    get {return _storage._isCommittee}
    set {_uniqueStorage()._isCommittee = newValue}
  }

  /// frozen asset(for asset issuer)
  public var frozenSupply: [Protocol_Account.Frozen] {
    get {return _storage._frozenSupply}
    set {_uniqueStorage()._frozenSupply = newValue}
  }

  /// asset_issued_name
  public var assetIssuedName: Data {
    get {return _storage._assetIssuedName}
    set {_uniqueStorage()._assetIssuedName = newValue}
  }

  public var assetIssuedID: Data {
    get {return _storage._assetIssuedID}
    set {_uniqueStorage()._assetIssuedID = newValue}
  }

  public var latestAssetOperationTime: Dictionary<String,Int64> {
    get {return _storage._latestAssetOperationTime}
    set {_uniqueStorage()._latestAssetOperationTime = newValue}
  }

  public var latestAssetOperationTimeV2: Dictionary<String,Int64> {
    get {return _storage._latestAssetOperationTimeV2}
    set {_uniqueStorage()._latestAssetOperationTimeV2 = newValue}
  }

  public var freeNetUsage: Int64 {
    get {return _storage._freeNetUsage}
    set {_uniqueStorage()._freeNetUsage = newValue}
  }

  public var freeAssetNetUsage: Dictionary<String,Int64> {
    get {return _storage._freeAssetNetUsage}
    set {_uniqueStorage()._freeAssetNetUsage = newValue}
  }

  public var freeAssetNetUsageV2: Dictionary<String,Int64> {
    get {return _storage._freeAssetNetUsageV2}
    set {_uniqueStorage()._freeAssetNetUsageV2 = newValue}
  }

  public var latestConsumeTime: Int64 {
    get {return _storage._latestConsumeTime}
    set {_uniqueStorage()._latestConsumeTime = newValue}
  }

  public var latestConsumeFreeTime: Int64 {
    get {return _storage._latestConsumeFreeTime}
    set {_uniqueStorage()._latestConsumeFreeTime = newValue}
  }

  /// the identity of this account, case insensitive
  public var accountID: Data {
    get {return _storage._accountID}
    set {_uniqueStorage()._accountID = newValue}
  }

  public var accountResource: Protocol_Account.AccountResource {
    get {return _storage._accountResource ?? Protocol_Account.AccountResource()}
    set {_uniqueStorage()._accountResource = newValue}
  }
  /// Returns true if `accountResource` has been explicitly set.
  public var hasAccountResource: Bool {return _storage._accountResource != nil}
  /// Clears the value of `accountResource`. Subsequent reads from it will return its default value.
  public mutating func clearAccountResource() {_uniqueStorage()._accountResource = nil}

  public var codeHash: Data {
    get {return _storage._codeHash}
    set {_uniqueStorage()._codeHash = newValue}
  }

  public var ownerPermission: Protocol_Permission {
    get {return _storage._ownerPermission ?? Protocol_Permission()}
    set {_uniqueStorage()._ownerPermission = newValue}
  }
  /// Returns true if `ownerPermission` has been explicitly set.
  public var hasOwnerPermission: Bool {return _storage._ownerPermission != nil}
  /// Clears the value of `ownerPermission`. Subsequent reads from it will return its default value.
  public mutating func clearOwnerPermission() {_uniqueStorage()._ownerPermission = nil}

  public var witnessPermission: Protocol_Permission {
    get {return _storage._witnessPermission ?? Protocol_Permission()}
    set {_uniqueStorage()._witnessPermission = newValue}
  }
  /// Returns true if `witnessPermission` has been explicitly set.
  public var hasWitnessPermission: Bool {return _storage._witnessPermission != nil}
  /// Clears the value of `witnessPermission`. Subsequent reads from it will return its default value.
  public mutating func clearWitnessPermission() {_uniqueStorage()._witnessPermission = nil}

  public var activePermission: [Protocol_Permission] {
    get {return _storage._activePermission}
    set {_uniqueStorage()._activePermission = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  /// frozen balance 
  public struct Frozen {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// the frozen trx balance
    public var frozenBalance: Int64 = 0

    /// the expire time
    public var expireTime: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public struct AccountResource {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// energy resource, get from frozen
    public var energyUsage: Int64 = 0

    /// the frozen balance for energy
    public var frozenBalanceForEnergy: Protocol_Account.Frozen {
      get {return _frozenBalanceForEnergy ?? Protocol_Account.Frozen()}
      set {_frozenBalanceForEnergy = newValue}
    }
    /// Returns true if `frozenBalanceForEnergy` has been explicitly set.
    public var hasFrozenBalanceForEnergy: Bool {return self._frozenBalanceForEnergy != nil}
    /// Clears the value of `frozenBalanceForEnergy`. Subsequent reads from it will return its default value.
    public mutating func clearFrozenBalanceForEnergy() {self._frozenBalanceForEnergy = nil}

    public var latestConsumeTimeForEnergy: Int64 = 0

    ///Frozen balance provided by other accounts to this account
    public var acquiredDelegatedFrozenBalanceForEnergy: Int64 = 0

    ///Frozen balances provided to other accounts
    public var delegatedFrozenBalanceForEnergy: Int64 = 0

    /// storage resource, get from market
    public var storageLimit: Int64 = 0

    public var storageUsage: Int64 = 0

    public var latestExchangeStorageTime: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _frozenBalanceForEnergy: Protocol_Account.Frozen? = nil
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Protocol_Key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = SwiftProtobuf.Internal.emptyData

  public var weight: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DelegatedResource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Data = SwiftProtobuf.Internal.emptyData

  public var to: Data = SwiftProtobuf.Internal.emptyData

  public var frozenBalanceForBandwidth: Int64 = 0

  public var frozenBalanceForEnergy: Int64 = 0

  public var expireTimeForBandwidth: Int64 = 0

  public var expireTimeForEnergy: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_authority {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Protocol_AccountId {
    get {return _account ?? Protocol_AccountId()}
    set {_account = newValue}
  }
  /// Returns true if `account` has been explicitly set.
  public var hasAccount: Bool {return self._account != nil}
  /// Clears the value of `account`. Subsequent reads from it will return its default value.
  public mutating func clearAccount() {self._account = nil}

  public var permissionName: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _account: Protocol_AccountId? = nil
}

public struct Protocol_Permission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_Permission.PermissionType = .owner

  ///Owner id=0, Witness id=1, Active id start by 2
  public var id: Int32 = 0

  public var permissionName: String = String()

  public var threshold: Int64 = 0

  public var parentID: Int32 = 0

  ///1 bit 1 contract
  public var operations: Data = SwiftProtobuf.Internal.emptyData

  public var keys: [Protocol_Key] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum PermissionType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case owner // = 0
    case witness // = 1
    case active // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .owner
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .owner
      case 1: self = .witness
      case 2: self = .active
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .owner: return 0
      case .witness: return 1
      case .active: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Permission.PermissionType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Permission.PermissionType] = [
    .owner,
    .witness,
    .active,
  ]
}

#endif  // swift(>=4.2)

/// Witness
public struct Protocol_Witness {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = SwiftProtobuf.Internal.emptyData

  public var voteCount: Int64 = 0

  public var pubKey: Data = SwiftProtobuf.Internal.emptyData

  public var url: String = String()

  public var totalProduced: Int64 = 0

  public var totalMissed: Int64 = 0

  public var latestBlockNum: Int64 = 0

  public var latestSlotNum: Int64 = 0

  public var isJobs: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Vote Change
public struct Protocol_Votes {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: Data = SwiftProtobuf.Internal.emptyData

  public var oldVotes: [Protocol_Vote] = []

  public var newVotes: [Protocol_Vote] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TXOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var value: Int64 = 0

  public var pubKeyHash: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TXInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_TXInput.raw {
    get {return _rawData ?? Protocol_TXInput.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  public var signature: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var txID: Data = SwiftProtobuf.Internal.emptyData

    public var vout: Int64 = 0

    public var pubKey: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_TXInput.raw? = nil
}

public struct Protocol_TXOutputs {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var outputs: [Protocol_TXOutput] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_ResourceReceipt {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var energyUsage: Int64 = 0

  public var energyFee: Int64 = 0

  public var originEnergyUsage: Int64 = 0

  public var energyUsageTotal: Int64 = 0

  public var netUsage: Int64 = 0

  public var netFee: Int64 = 0

  public var result: Protocol_Transaction.Result.contractResult = .default

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_Transaction.raw {
    get {return _rawData ?? Protocol_Transaction.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  /// only support size = 1, repeated list here for muti-sig extension
  public var signature: [Data] = []

  public var ret: [Protocol_Transaction.Result] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct Contract {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var type: Protocol_Transaction.Contract.ContractType = .accountCreateContract

    public var parameter: SwiftProtobuf.Google_Protobuf_Any {
      get {return _parameter ?? SwiftProtobuf.Google_Protobuf_Any()}
      set {_parameter = newValue}
    }
    /// Returns true if `parameter` has been explicitly set.
    public var hasParameter: Bool {return self._parameter != nil}
    /// Clears the value of `parameter`. Subsequent reads from it will return its default value.
    public mutating func clearParameter() {self._parameter = nil}

    public var provider: Data = SwiftProtobuf.Internal.emptyData

    public var contractName: Data = SwiftProtobuf.Internal.emptyData

    public var permissionID: Int32 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum ContractType: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case accountCreateContract // = 0
      case transferContract // = 1
      case transferAssetContract // = 2
      case voteAssetContract // = 3
      case voteWitnessContract // = 4
      case witnessCreateContract // = 5
      case assetIssueContract // = 6
      case witnessUpdateContract // = 8
      case participateAssetIssueContract // = 9
      case accountUpdateContract // = 10
      case freezeBalanceContract // = 11
      case unfreezeBalanceContract // = 12
      case withdrawBalanceContract // = 13
      case unfreezeAssetContract // = 14
      case updateAssetContract // = 15
      case proposalCreateContract // = 16
      case proposalApproveContract // = 17
      case proposalDeleteContract // = 18
      case setAccountIDContract // = 19
      case customContract // = 20
      case createSmartContract // = 30
      case triggerSmartContract // = 31
      case getContract // = 32
      case updateSettingContract // = 33
      case exchangeCreateContract // = 41
      case exchangeInjectContract // = 42
      case exchangeWithdrawContract // = 43
      case exchangeTransactionContract // = 44
      case updateEnergyLimitContract // = 45
      case accountPermissionUpdateContract // = 46
      case clearAbicontract // = 48
      case updateBrokerageContract // = 49
      case shieldedTransferContract // = 51
      case UNRECOGNIZED(Int)

      public init() {
        self = .accountCreateContract
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .accountCreateContract
        case 1: self = .transferContract
        case 2: self = .transferAssetContract
        case 3: self = .voteAssetContract
        case 4: self = .voteWitnessContract
        case 5: self = .witnessCreateContract
        case 6: self = .assetIssueContract
        case 8: self = .witnessUpdateContract
        case 9: self = .participateAssetIssueContract
        case 10: self = .accountUpdateContract
        case 11: self = .freezeBalanceContract
        case 12: self = .unfreezeBalanceContract
        case 13: self = .withdrawBalanceContract
        case 14: self = .unfreezeAssetContract
        case 15: self = .updateAssetContract
        case 16: self = .proposalCreateContract
        case 17: self = .proposalApproveContract
        case 18: self = .proposalDeleteContract
        case 19: self = .setAccountIDContract
        case 20: self = .customContract
        case 30: self = .createSmartContract
        case 31: self = .triggerSmartContract
        case 32: self = .getContract
        case 33: self = .updateSettingContract
        case 41: self = .exchangeCreateContract
        case 42: self = .exchangeInjectContract
        case 43: self = .exchangeWithdrawContract
        case 44: self = .exchangeTransactionContract
        case 45: self = .updateEnergyLimitContract
        case 46: self = .accountPermissionUpdateContract
        case 48: self = .clearAbicontract
        case 49: self = .updateBrokerageContract
        case 51: self = .shieldedTransferContract
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .accountCreateContract: return 0
        case .transferContract: return 1
        case .transferAssetContract: return 2
        case .voteAssetContract: return 3
        case .voteWitnessContract: return 4
        case .witnessCreateContract: return 5
        case .assetIssueContract: return 6
        case .witnessUpdateContract: return 8
        case .participateAssetIssueContract: return 9
        case .accountUpdateContract: return 10
        case .freezeBalanceContract: return 11
        case .unfreezeBalanceContract: return 12
        case .withdrawBalanceContract: return 13
        case .unfreezeAssetContract: return 14
        case .updateAssetContract: return 15
        case .proposalCreateContract: return 16
        case .proposalApproveContract: return 17
        case .proposalDeleteContract: return 18
        case .setAccountIDContract: return 19
        case .customContract: return 20
        case .createSmartContract: return 30
        case .triggerSmartContract: return 31
        case .getContract: return 32
        case .updateSettingContract: return 33
        case .exchangeCreateContract: return 41
        case .exchangeInjectContract: return 42
        case .exchangeWithdrawContract: return 43
        case .exchangeTransactionContract: return 44
        case .updateEnergyLimitContract: return 45
        case .accountPermissionUpdateContract: return 46
        case .clearAbicontract: return 48
        case .updateBrokerageContract: return 49
        case .shieldedTransferContract: return 51
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}

    fileprivate var _parameter: SwiftProtobuf.Google_Protobuf_Any? = nil
  }

  public struct Result {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var fee: Int64 = 0

    public var ret: Protocol_Transaction.Result.code = .sucess

    public var contractRet: Protocol_Transaction.Result.contractResult = .default

    public var assetIssueID: String = String()

    public var withdrawAmount: Int64 = 0

    public var unfreezeAmount: Int64 = 0

    public var exchangeReceivedAmount: Int64 = 0

    public var exchangeInjectAnotherAmount: Int64 = 0

    public var exchangeWithdrawAnotherAmount: Int64 = 0

    public var exchangeID: Int64 = 0

    public var shieldedTransactionFee: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum code: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case sucess // = 0
      case failed // = 1
      case UNRECOGNIZED(Int)

      public init() {
        self = .sucess
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .sucess
        case 1: self = .failed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .sucess: return 0
        case .failed: return 1
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public enum contractResult: SwiftProtobuf.Enum {
      public typealias RawValue = Int
      case `default` // = 0
      case success // = 1
      case revert // = 2
      case badJumpDestination // = 3
      case outOfMemory // = 4
      case precompiledContract // = 5
      case stackTooSmall // = 6
      case stackTooLarge // = 7
      case illegalOperation // = 8
      case stackOverflow // = 9
      case outOfEnergy // = 10
      case outOfTime // = 11
      case jvmStackOverFlow // = 12
      case unknown // = 13
      case transferFailed // = 14
      case UNRECOGNIZED(Int)

      public init() {
        self = .default
      }

      public init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .default
        case 1: self = .success
        case 2: self = .revert
        case 3: self = .badJumpDestination
        case 4: self = .outOfMemory
        case 5: self = .precompiledContract
        case 6: self = .stackTooSmall
        case 7: self = .stackTooLarge
        case 8: self = .illegalOperation
        case 9: self = .stackOverflow
        case 10: self = .outOfEnergy
        case 11: self = .outOfTime
        case 12: self = .jvmStackOverFlow
        case 13: self = .unknown
        case 14: self = .transferFailed
        default: self = .UNRECOGNIZED(rawValue)
        }
      }

      public var rawValue: Int {
        switch self {
        case .default: return 0
        case .success: return 1
        case .revert: return 2
        case .badJumpDestination: return 3
        case .outOfMemory: return 4
        case .precompiledContract: return 5
        case .stackTooSmall: return 6
        case .stackTooLarge: return 7
        case .illegalOperation: return 8
        case .stackOverflow: return 9
        case .outOfEnergy: return 10
        case .outOfTime: return 11
        case .jvmStackOverFlow: return 12
        case .unknown: return 13
        case .transferFailed: return 14
        case .UNRECOGNIZED(let i): return i
        }
      }

    }

    public init() {}
  }

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var refBlockBytes: Data = SwiftProtobuf.Internal.emptyData

    public var refBlockNum: Int64 = 0

    public var refBlockHash: Data = SwiftProtobuf.Internal.emptyData

    public var expiration: Int64 = 0

    public var auths: [Protocol_authority] = []

    /// transaction note
    public var data: Data = SwiftProtobuf.Internal.emptyData

    ///only support size = 1, repeated list here for extension
    public var contract: [Protocol_Transaction.Contract] = []

    /// scripts not used
    public var scripts: Data = SwiftProtobuf.Internal.emptyData

    public var timestamp: Int64 = 0

    public var feeLimit: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_Transaction.raw? = nil
}

#if swift(>=4.2)

extension Protocol_Transaction.Contract.ContractType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Transaction.Contract.ContractType] = [
    .accountCreateContract,
    .transferContract,
    .transferAssetContract,
    .voteAssetContract,
    .voteWitnessContract,
    .witnessCreateContract,
    .assetIssueContract,
    .witnessUpdateContract,
    .participateAssetIssueContract,
    .accountUpdateContract,
    .freezeBalanceContract,
    .unfreezeBalanceContract,
    .withdrawBalanceContract,
    .unfreezeAssetContract,
    .updateAssetContract,
    .proposalCreateContract,
    .proposalApproveContract,
    .proposalDeleteContract,
    .setAccountIDContract,
    .customContract,
    .createSmartContract,
    .triggerSmartContract,
    .getContract,
    .updateSettingContract,
    .exchangeCreateContract,
    .exchangeInjectContract,
    .exchangeWithdrawContract,
    .exchangeTransactionContract,
    .updateEnergyLimitContract,
    .accountPermissionUpdateContract,
    .clearAbicontract,
    .updateBrokerageContract,
    .shieldedTransferContract,
  ]
}

extension Protocol_Transaction.Result.code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Transaction.Result.code] = [
    .sucess,
    .failed,
  ]
}

extension Protocol_Transaction.Result.contractResult: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Transaction.Result.contractResult] = [
    .default,
    .success,
    .revert,
    .badJumpDestination,
    .outOfMemory,
    .precompiledContract,
    .stackTooSmall,
    .stackTooLarge,
    .illegalOperation,
    .stackOverflow,
    .outOfEnergy,
    .outOfTime,
    .jvmStackOverFlow,
    .unknown,
    .transferFailed,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_TransactionInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Data {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  public var fee: Int64 {
    get {return _storage._fee}
    set {_uniqueStorage()._fee = newValue}
  }

  public var blockNumber: Int64 {
    get {return _storage._blockNumber}
    set {_uniqueStorage()._blockNumber = newValue}
  }

  public var blockTimeStamp: Int64 {
    get {return _storage._blockTimeStamp}
    set {_uniqueStorage()._blockTimeStamp = newValue}
  }

  public var contractResult: [Data] {
    get {return _storage._contractResult}
    set {_uniqueStorage()._contractResult = newValue}
  }

  public var contractAddress: Data {
    get {return _storage._contractAddress}
    set {_uniqueStorage()._contractAddress = newValue}
  }

  public var receipt: Protocol_ResourceReceipt {
    get {return _storage._receipt ?? Protocol_ResourceReceipt()}
    set {_uniqueStorage()._receipt = newValue}
  }
  /// Returns true if `receipt` has been explicitly set.
  public var hasReceipt: Bool {return _storage._receipt != nil}
  /// Clears the value of `receipt`. Subsequent reads from it will return its default value.
  public mutating func clearReceipt() {_uniqueStorage()._receipt = nil}

  public var log: [Protocol_TransactionInfo.Log] {
    get {return _storage._log}
    set {_uniqueStorage()._log = newValue}
  }

  public var result: Protocol_TransactionInfo.code {
    get {return _storage._result}
    set {_uniqueStorage()._result = newValue}
  }

  public var resMessage: Data {
    get {return _storage._resMessage}
    set {_uniqueStorage()._resMessage = newValue}
  }

  public var assetIssueID: String {
    get {return _storage._assetIssueID}
    set {_uniqueStorage()._assetIssueID = newValue}
  }

  public var withdrawAmount: Int64 {
    get {return _storage._withdrawAmount}
    set {_uniqueStorage()._withdrawAmount = newValue}
  }

  public var unfreezeAmount: Int64 {
    get {return _storage._unfreezeAmount}
    set {_uniqueStorage()._unfreezeAmount = newValue}
  }

  public var internalTransactions: [Protocol_InternalTransaction] {
    get {return _storage._internalTransactions}
    set {_uniqueStorage()._internalTransactions = newValue}
  }

  public var exchangeReceivedAmount: Int64 {
    get {return _storage._exchangeReceivedAmount}
    set {_uniqueStorage()._exchangeReceivedAmount = newValue}
  }

  public var exchangeInjectAnotherAmount: Int64 {
    get {return _storage._exchangeInjectAnotherAmount}
    set {_uniqueStorage()._exchangeInjectAnotherAmount = newValue}
  }

  public var exchangeWithdrawAnotherAmount: Int64 {
    get {return _storage._exchangeWithdrawAnotherAmount}
    set {_uniqueStorage()._exchangeWithdrawAnotherAmount = newValue}
  }

  public var exchangeID: Int64 {
    get {return _storage._exchangeID}
    set {_uniqueStorage()._exchangeID = newValue}
  }

  public var shieldedTransactionFee: Int64 {
    get {return _storage._shieldedTransactionFee}
    set {_uniqueStorage()._shieldedTransactionFee = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum code: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sucess // = 0
    case failed // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .sucess
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sucess
      case 1: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sucess: return 0
      case .failed: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct Log {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var address: Data = SwiftProtobuf.Internal.emptyData

    public var topics: [Data] = []

    public var data: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension Protocol_TransactionInfo.code: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_TransactionInfo.code] = [
    .sucess,
    .failed,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_TransactionRet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var blockNumber: Int64 = 0

  public var blockTimeStamp: Int64 = 0

  public var transactioninfo: [Protocol_TransactionInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_Transactions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactions: [Protocol_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_TransactionSign {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transaction: Protocol_Transaction {
    get {return _transaction ?? Protocol_Transaction()}
    set {_transaction = newValue}
  }
  /// Returns true if `transaction` has been explicitly set.
  public var hasTransaction: Bool {return self._transaction != nil}
  /// Clears the value of `transaction`. Subsequent reads from it will return its default value.
  public mutating func clearTransaction() {self._transaction = nil}

  public var privateKey: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _transaction: Protocol_Transaction? = nil
}

public struct Protocol_BlockHeader {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var rawData: Protocol_BlockHeader.raw {
    get {return _rawData ?? Protocol_BlockHeader.raw()}
    set {_rawData = newValue}
  }
  /// Returns true if `rawData` has been explicitly set.
  public var hasRawData: Bool {return self._rawData != nil}
  /// Clears the value of `rawData`. Subsequent reads from it will return its default value.
  public mutating func clearRawData() {self._rawData = nil}

  public var witnessSignature: Data = SwiftProtobuf.Internal.emptyData

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct raw {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var timestamp: Int64 = 0

    public var txTrieRoot: Data = SwiftProtobuf.Internal.emptyData

    public var parentHash: Data = SwiftProtobuf.Internal.emptyData

    ///bytes nonce = 5;
    ///bytes difficulty = 6;
    public var number: Int64 = 0

    public var witnessID: Int64 = 0

    public var witnessAddress: Data = SwiftProtobuf.Internal.emptyData

    public var version: Int32 = 0

    public var accountStateRoot: Data = SwiftProtobuf.Internal.emptyData

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _rawData: Protocol_BlockHeader.raw? = nil
}

/// block
public struct Protocol_Block {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var transactions: [Protocol_Transaction] = []

  public var blockHeader: Protocol_BlockHeader {
    get {return _blockHeader ?? Protocol_BlockHeader()}
    set {_blockHeader = newValue}
  }
  /// Returns true if `blockHeader` has been explicitly set.
  public var hasBlockHeader: Bool {return self._blockHeader != nil}
  /// Clears the value of `blockHeader`. Subsequent reads from it will return its default value.
  public mutating func clearBlockHeader() {self._blockHeader = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _blockHeader: Protocol_BlockHeader? = nil
}

public struct Protocol_ChainInventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Protocol_ChainInventory.BlockId] = []

  public var remainNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: Data = SwiftProtobuf.Internal.emptyData

    public var number: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

/// Inventory
public struct Protocol_BlockInventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Protocol_BlockInventory.BlockId] = []

  public var type: Protocol_BlockInventory.TypeEnum = .sync

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum TypeEnum: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case sync // = 0
    case advtise // = 1
    case fetch // = 2
    case UNRECOGNIZED(Int)

    public init() {
      self = .sync
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .sync
      case 1: self = .advtise
      case 2: self = .fetch
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .sync: return 0
      case .advtise: return 1
      case .fetch: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: Data = SwiftProtobuf.Internal.emptyData

    public var number: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_BlockInventory.TypeEnum: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_BlockInventory.TypeEnum] = [
    .sync,
    .advtise,
    .fetch,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_Inventory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_Inventory.InventoryType = .trx

  public var ids: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum InventoryType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case trx // = 0
    case block // = 1
    case UNRECOGNIZED(Int)

    public init() {
      self = .trx
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .trx
      case 1: self = .block
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .trx: return 0
      case .block: return 1
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Inventory.InventoryType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Inventory.InventoryType] = [
    .trx,
    .block,
  ]
}

#endif  // swift(>=4.2)

public struct Protocol_Items {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: Protocol_Items.ItemType = .err

  public var blocks: [Protocol_Block] = []

  public var blockHeaders: [Protocol_BlockHeader] = []

  public var transactions: [Protocol_Transaction] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum ItemType: SwiftProtobuf.Enum {
    public typealias RawValue = Int
    case err // = 0
    case trx // = 1
    case block // = 2
    case blockheader // = 3
    case UNRECOGNIZED(Int)

    public init() {
      self = .err
    }

    public init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .err
      case 1: self = .trx
      case 2: self = .block
      case 3: self = .blockheader
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    public var rawValue: Int {
      switch self {
      case .err: return 0
      case .trx: return 1
      case .block: return 2
      case .blockheader: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  public init() {}
}

#if swift(>=4.2)

extension Protocol_Items.ItemType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static var allCases: [Protocol_Items.ItemType] = [
    .err,
    .trx,
    .block,
    .blockheader,
  ]
}

#endif  // swift(>=4.2)

/// DynamicProperties
public struct Protocol_DynamicProperties {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var lastSolidityBlockNum: Int64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_DisconnectMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reason: Protocol_ReasonCode = .requested

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_HelloMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var from: Protocol_Endpoint {
    get {return _from ?? Protocol_Endpoint()}
    set {_from = newValue}
  }
  /// Returns true if `from` has been explicitly set.
  public var hasFrom: Bool {return self._from != nil}
  /// Clears the value of `from`. Subsequent reads from it will return its default value.
  public mutating func clearFrom() {self._from = nil}

  public var version: Int32 = 0

  public var timestamp: Int64 = 0

  public var genesisBlockID: Protocol_HelloMessage.BlockId {
    get {return _genesisBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_genesisBlockID = newValue}
  }
  /// Returns true if `genesisBlockID` has been explicitly set.
  public var hasGenesisBlockID: Bool {return self._genesisBlockID != nil}
  /// Clears the value of `genesisBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearGenesisBlockID() {self._genesisBlockID = nil}

  public var solidBlockID: Protocol_HelloMessage.BlockId {
    get {return _solidBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_solidBlockID = newValue}
  }
  /// Returns true if `solidBlockID` has been explicitly set.
  public var hasSolidBlockID: Bool {return self._solidBlockID != nil}
  /// Clears the value of `solidBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearSolidBlockID() {self._solidBlockID = nil}

  public var headBlockID: Protocol_HelloMessage.BlockId {
    get {return _headBlockID ?? Protocol_HelloMessage.BlockId()}
    set {_headBlockID = newValue}
  }
  /// Returns true if `headBlockID` has been explicitly set.
  public var hasHeadBlockID: Bool {return self._headBlockID != nil}
  /// Clears the value of `headBlockID`. Subsequent reads from it will return its default value.
  public mutating func clearHeadBlockID() {self._headBlockID = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct BlockId {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var hash: Data = SwiftProtobuf.Internal.emptyData

    public var number: Int64 = 0

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}

  fileprivate var _from: Protocol_Endpoint? = nil
  fileprivate var _genesisBlockID: Protocol_HelloMessage.BlockId? = nil
  fileprivate var _solidBlockID: Protocol_HelloMessage.BlockId? = nil
  fileprivate var _headBlockID: Protocol_HelloMessage.BlockId? = nil
}

public struct Protocol_InternalTransaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// internalTransaction identity, the root InternalTransaction hash
  /// should equals to root transaction id.
  public var hash: Data = SwiftProtobuf.Internal.emptyData

  /// the one send trx (TBD: or token) via function
  public var callerAddress: Data = SwiftProtobuf.Internal.emptyData

  /// the one recieve trx (TBD: or token) via function
  public var transferToAddress: Data = SwiftProtobuf.Internal.emptyData

  public var callValueInfo: [Protocol_InternalTransaction.CallValueInfo] = []

  public var note: Data = SwiftProtobuf.Internal.emptyData

  public var rejected: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct CallValueInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// trx (TBD: or token) value
    public var callValue: Int64 = 0

    /// TBD: tokenName, trx should be empty
    public var tokenID: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Protocol_DelegatedResourceAccountIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var account: Data = SwiftProtobuf.Internal.emptyData

  public var fromAccounts: [Data] = []

  public var toAccounts: [Data] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Protocol_NodeInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var beginSyncNum: Int64 = 0

  public var block: String = String()

  public var solidityBlock: String = String()

  ///connect information
  public var currentConnectCount: Int32 = 0

  public var activeConnectCount: Int32 = 0

  public var passiveConnectCount: Int32 = 0

  public var totalFlow: Int64 = 0

  public var peerInfoList: [Protocol_NodeInfo.PeerInfo] = []

  public var configNodeInfo: Protocol_NodeInfo.ConfigNodeInfo {
    get {return _configNodeInfo ?? Protocol_NodeInfo.ConfigNodeInfo()}
    set {_configNodeInfo = newValue}
  }
  /// Returns true if `configNodeInfo` has been explicitly set.
  public var hasConfigNodeInfo: Bool {return self._configNodeInfo != nil}
  /// Clears the value of `configNodeInfo`. Subsequent reads from it will return its default value.
  public mutating func clearConfigNodeInfo() {self._configNodeInfo = nil}

  public var machineInfo: Protocol_NodeInfo.MachineInfo {
    get {return _machineInfo ?? Protocol_NodeInfo.MachineInfo()}
    set {_machineInfo = newValue}
  }
  /// Returns true if `machineInfo` has been explicitly set.
  public var hasMachineInfo: Bool {return self._machineInfo != nil}
  /// Clears the value of `machineInfo`. Subsequent reads from it will return its default value.
  public mutating func clearMachineInfo() {self._machineInfo = nil}

  public var cheatWitnessInfoMap: Dictionary<String,String> = [:]

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PeerInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var lastSyncBlock: String {
      get {return _storage._lastSyncBlock}
      set {_uniqueStorage()._lastSyncBlock = newValue}
    }

    public var remainNum: Int64 {
      get {return _storage._remainNum}
      set {_uniqueStorage()._remainNum = newValue}
    }

    public var lastBlockUpdateTime: Int64 {
      get {return _storage._lastBlockUpdateTime}
      set {_uniqueStorage()._lastBlockUpdateTime = newValue}
    }

    public var syncFlag: Bool {
      get {return _storage._syncFlag}
      set {_uniqueStorage()._syncFlag = newValue}
    }

    public var headBlockTimeWeBothHave: Int64 {
      get {return _storage._headBlockTimeWeBothHave}
      set {_uniqueStorage()._headBlockTimeWeBothHave = newValue}
    }

    public var needSyncFromPeer: Bool {
      get {return _storage._needSyncFromPeer}
      set {_uniqueStorage()._needSyncFromPeer = newValue}
    }

    public var needSyncFromUs: Bool {
      get {return _storage._needSyncFromUs}
      set {_uniqueStorage()._needSyncFromUs = newValue}
    }

    public var host: String {
      get {return _storage._host}
      set {_uniqueStorage()._host = newValue}
    }

    public var port: Int32 {
      get {return _storage._port}
      set {_uniqueStorage()._port = newValue}
    }

    public var nodeID: String {
      get {return _storage._nodeID}
      set {_uniqueStorage()._nodeID = newValue}
    }

    public var connectTime: Int64 {
      get {return _storage._connectTime}
      set {_uniqueStorage()._connectTime = newValue}
    }

    public var avgLatency: Double {
      get {return _storage._avgLatency}
      set {_uniqueStorage()._avgLatency = newValue}
    }

    public var syncToFetchSize: Int32 {
      get {return _storage._syncToFetchSize}
      set {_uniqueStorage()._syncToFetchSize = newValue}
    }

    public var syncToFetchSizePeekNum: Int64 {
      get {return _storage._syncToFetchSizePeekNum}
      set {_uniqueStorage()._syncToFetchSizePeekNum = newValue}
    }

    public var syncBlockRequestedSize: Int32 {
      get {return _storage._syncBlockRequestedSize}
      set {_uniqueStorage()._syncBlockRequestedSize = newValue}
    }

    public var unFetchSynNum: Int64 {
      get {return _storage._unFetchSynNum}
      set {_uniqueStorage()._unFetchSynNum = newValue}
    }

    public var blockInPorcSize: Int32 {
      get {return _storage._blockInPorcSize}
      set {_uniqueStorage()._blockInPorcSize = newValue}
    }

    public var headBlockWeBothHave: String {
      get {return _storage._headBlockWeBothHave}
      set {_uniqueStorage()._headBlockWeBothHave = newValue}
    }

    public var isActive: Bool {
      get {return _storage._isActive}
      set {_uniqueStorage()._isActive = newValue}
    }

    public var score: Int32 {
      get {return _storage._score}
      set {_uniqueStorage()._score = newValue}
    }

    public var nodeCount: Int32 {
      get {return _storage._nodeCount}
      set {_uniqueStorage()._nodeCount = newValue}
    }

    public var inFlow: Int64 {
      get {return _storage._inFlow}
      set {_uniqueStorage()._inFlow = newValue}
    }

    public var disconnectTimes: Int32 {
      get {return _storage._disconnectTimes}
      set {_uniqueStorage()._disconnectTimes = newValue}
    }

    public var localDisconnectReason: String {
      get {return _storage._localDisconnectReason}
      set {_uniqueStorage()._localDisconnectReason = newValue}
    }

    public var remoteDisconnectReason: String {
      get {return _storage._remoteDisconnectReason}
      set {_uniqueStorage()._remoteDisconnectReason = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct ConfigNodeInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var codeVersion: String {
      get {return _storage._codeVersion}
      set {_uniqueStorage()._codeVersion = newValue}
    }

    public var p2PVersion: String {
      get {return _storage._p2PVersion}
      set {_uniqueStorage()._p2PVersion = newValue}
    }

    public var listenPort: Int32 {
      get {return _storage._listenPort}
      set {_uniqueStorage()._listenPort = newValue}
    }

    public var discoverEnable: Bool {
      get {return _storage._discoverEnable}
      set {_uniqueStorage()._discoverEnable = newValue}
    }

    public var activeNodeSize: Int32 {
      get {return _storage._activeNodeSize}
      set {_uniqueStorage()._activeNodeSize = newValue}
    }

    public var passiveNodeSize: Int32 {
      get {return _storage._passiveNodeSize}
      set {_uniqueStorage()._passiveNodeSize = newValue}
    }

    public var sendNodeSize: Int32 {
      get {return _storage._sendNodeSize}
      set {_uniqueStorage()._sendNodeSize = newValue}
    }

    public var maxConnectCount: Int32 {
      get {return _storage._maxConnectCount}
      set {_uniqueStorage()._maxConnectCount = newValue}
    }

    public var sameIpMaxConnectCount: Int32 {
      get {return _storage._sameIpMaxConnectCount}
      set {_uniqueStorage()._sameIpMaxConnectCount = newValue}
    }

    public var backupListenPort: Int32 {
      get {return _storage._backupListenPort}
      set {_uniqueStorage()._backupListenPort = newValue}
    }

    public var backupMemberSize: Int32 {
      get {return _storage._backupMemberSize}
      set {_uniqueStorage()._backupMemberSize = newValue}
    }

    public var backupPriority: Int32 {
      get {return _storage._backupPriority}
      set {_uniqueStorage()._backupPriority = newValue}
    }

    public var dbVersion: Int32 {
      get {return _storage._dbVersion}
      set {_uniqueStorage()._dbVersion = newValue}
    }

    public var minParticipationRate: Int32 {
      get {return _storage._minParticipationRate}
      set {_uniqueStorage()._minParticipationRate = newValue}
    }

    public var supportConstant: Bool {
      get {return _storage._supportConstant}
      set {_uniqueStorage()._supportConstant = newValue}
    }

    public var minTimeRatio: Double {
      get {return _storage._minTimeRatio}
      set {_uniqueStorage()._minTimeRatio = newValue}
    }

    public var maxTimeRatio: Double {
      get {return _storage._maxTimeRatio}
      set {_uniqueStorage()._maxTimeRatio = newValue}
    }

    public var allowCreationOfContracts: Int64 {
      get {return _storage._allowCreationOfContracts}
      set {_uniqueStorage()._allowCreationOfContracts = newValue}
    }

    public var allowAdaptiveEnergy: Int64 {
      get {return _storage._allowAdaptiveEnergy}
      set {_uniqueStorage()._allowAdaptiveEnergy = newValue}
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  public struct MachineInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var threadCount: Int32 = 0

    public var deadLockThreadCount: Int32 = 0

    public var cpuCount: Int32 = 0

    public var totalMemory: Int64 = 0

    public var freeMemory: Int64 = 0

    public var cpuRate: Double = 0

    public var javaVersion: String = String()

    public var osName: String = String()

    public var jvmTotalMemoery: Int64 = 0

    public var jvmFreeMemory: Int64 = 0

    public var processCpuRate: Double = 0

    public var memoryDescInfoList: [Protocol_NodeInfo.MachineInfo.MemoryDescInfo] = []

    public var deadLockThreadInfoList: [Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public struct MemoryDescInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var initSize: Int64 = 0

      public var useSize: Int64 = 0

      public var maxSize: Int64 = 0

      public var useRate: Double = 0

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public struct DeadLockThreadInfo {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      public var name: String = String()

      public var lockName: String = String()

      public var lockOwner: String = String()

      public var state: String = String()

      public var blockTime: Int64 = 0

      public var waitTime: Int64 = 0

      public var stackTrace: String = String()

      public var unknownFields = SwiftProtobuf.UnknownStorage()

      public init() {}
    }

    public init() {}
  }

  public init() {}

  fileprivate var _configNodeInfo: Protocol_NodeInfo.ConfigNodeInfo? = nil
  fileprivate var _machineInfo: Protocol_NodeInfo.MachineInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "protocol"

extension Protocol_AccountType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Normal"),
    1: .same(proto: "AssetIssue"),
    2: .same(proto: "Contract"),
  ]
}

extension Protocol_ReasonCode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REQUESTED"),
    2: .same(proto: "BAD_PROTOCOL"),
    4: .same(proto: "TOO_MANY_PEERS"),
    5: .same(proto: "DUPLICATE_PEER"),
    6: .same(proto: "INCOMPATIBLE_PROTOCOL"),
    7: .same(proto: "NULL_IDENTITY"),
    8: .same(proto: "PEER_QUITING"),
    9: .same(proto: "UNEXPECTED_IDENTITY"),
    10: .same(proto: "LOCAL_IDENTITY"),
    11: .same(proto: "PING_TIMEOUT"),
    16: .same(proto: "USER_REASON"),
    17: .same(proto: "RESET"),
    18: .same(proto: "SYNC_FAIL"),
    19: .same(proto: "FETCH_FAIL"),
    20: .same(proto: "BAD_TX"),
    21: .same(proto: "BAD_BLOCK"),
    22: .same(proto: "FORKED"),
    23: .same(proto: "UNLINKABLE"),
    24: .same(proto: "INCOMPATIBLE_VERSION"),
    25: .same(proto: "INCOMPATIBLE_CHAIN"),
    32: .same(proto: "TIME_OUT"),
    33: .same(proto: "CONNECT_FAIL"),
    34: .same(proto: "TOO_MANY_PEERS_WITH_SAME_IP"),
    255: .same(proto: "UNKNOWN"),
  ]
}

extension Protocol_AccountId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AccountId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.name)
      case 2: try decoder.decodeSingularBytesField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularBytesField(value: self.name, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_AccountId, rhs: Protocol_AccountId) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Vote"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "vote_address"),
    2: .standard(proto: "vote_count"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.voteAddress)
      case 2: try decoder.decodeSingularInt64Field(value: &self.voteCount)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voteAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.voteAddress, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Vote, rhs: Protocol_Vote) -> Bool {
    if lhs.voteAddress != rhs.voteAddress {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Proposal"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .standard(proto: "proposer_address"),
    3: .same(proto: "parameters"),
    4: .standard(proto: "expiration_time"),
    5: .standard(proto: "create_time"),
    6: .same(proto: "approvals"),
    7: .same(proto: "state"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      case 2: try decoder.decodeSingularBytesField(value: &self.proposerAddress)
      case 3: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: &self.parameters)
      case 4: try decoder.decodeSingularInt64Field(value: &self.expirationTime)
      case 5: try decoder.decodeSingularInt64Field(value: &self.createTime)
      case 6: try decoder.decodeRepeatedBytesField(value: &self.approvals)
      case 7: try decoder.decodeSingularEnumField(value: &self.state)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.proposerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposerAddress, fieldNumber: 2)
    }
    if !self.parameters.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt64,SwiftProtobuf.ProtobufInt64>.self, value: self.parameters, fieldNumber: 3)
    }
    if self.expirationTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expirationTime, fieldNumber: 4)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 5)
    }
    if !self.approvals.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.approvals, fieldNumber: 6)
    }
    if self.state != .pending {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Proposal, rhs: Protocol_Proposal) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.proposerAddress != rhs.proposerAddress {return false}
    if lhs.parameters != rhs.parameters {return false}
    if lhs.expirationTime != rhs.expirationTime {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.approvals != rhs.approvals {return false}
    if lhs.state != rhs.state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Proposal.State: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PENDING"),
    1: .same(proto: "DISAPPROVED"),
    2: .same(proto: "APPROVED"),
    3: .same(proto: "CANCELED"),
  ]
}

extension Protocol_Exchange: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Exchange"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "exchange_id"),
    2: .standard(proto: "creator_address"),
    3: .standard(proto: "create_time"),
    6: .standard(proto: "first_token_id"),
    7: .standard(proto: "first_token_balance"),
    8: .standard(proto: "second_token_id"),
    9: .standard(proto: "second_token_balance"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.exchangeID)
      case 2: try decoder.decodeSingularBytesField(value: &self.creatorAddress)
      case 3: try decoder.decodeSingularInt64Field(value: &self.createTime)
      case 6: try decoder.decodeSingularBytesField(value: &self.firstTokenID)
      case 7: try decoder.decodeSingularInt64Field(value: &self.firstTokenBalance)
      case 8: try decoder.decodeSingularBytesField(value: &self.secondTokenID)
      case 9: try decoder.decodeSingularInt64Field(value: &self.secondTokenBalance)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 1)
    }
    if !self.creatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.creatorAddress, fieldNumber: 2)
    }
    if self.createTime != 0 {
      try visitor.visitSingularInt64Field(value: self.createTime, fieldNumber: 3)
    }
    if !self.firstTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.firstTokenID, fieldNumber: 6)
    }
    if self.firstTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.firstTokenBalance, fieldNumber: 7)
    }
    if !self.secondTokenID.isEmpty {
      try visitor.visitSingularBytesField(value: self.secondTokenID, fieldNumber: 8)
    }
    if self.secondTokenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.secondTokenBalance, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Exchange, rhs: Protocol_Exchange) -> Bool {
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.creatorAddress != rhs.creatorAddress {return false}
    if lhs.createTime != rhs.createTime {return false}
    if lhs.firstTokenID != rhs.firstTokenID {return false}
    if lhs.firstTokenBalance != rhs.firstTokenBalance {return false}
    if lhs.secondTokenID != rhs.secondTokenID {return false}
    if lhs.secondTokenBalance != rhs.secondTokenBalance {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainParameters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainParameters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainParameter"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.chainParameter)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainParameter.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.chainParameter, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainParameters, rhs: Protocol_ChainParameters) -> Bool {
    if lhs.chainParameter != rhs.chainParameter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainParameters.ChainParameter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_ChainParameters.protoMessageName + ".ChainParameter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.key)
      case 2: try decoder.decodeSingularInt64Field(value: &self.value)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainParameters.ChainParameter, rhs: Protocol_ChainParameters.ChainParameter) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Account"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_name"),
    2: .same(proto: "type"),
    3: .same(proto: "address"),
    4: .same(proto: "balance"),
    5: .same(proto: "votes"),
    6: .same(proto: "asset"),
    56: .same(proto: "assetV2"),
    7: .same(proto: "frozen"),
    8: .standard(proto: "net_usage"),
    41: .standard(proto: "acquired_delegated_frozen_balance_for_bandwidth"),
    42: .standard(proto: "delegated_frozen_balance_for_bandwidth"),
    9: .standard(proto: "create_time"),
    10: .standard(proto: "latest_opration_time"),
    11: .same(proto: "allowance"),
    12: .standard(proto: "latest_withdraw_time"),
    13: .same(proto: "code"),
    14: .standard(proto: "is_witness"),
    15: .standard(proto: "is_committee"),
    16: .standard(proto: "frozen_supply"),
    17: .standard(proto: "asset_issued_name"),
    57: .standard(proto: "asset_issued_ID"),
    18: .standard(proto: "latest_asset_operation_time"),
    58: .standard(proto: "latest_asset_operation_timeV2"),
    19: .standard(proto: "free_net_usage"),
    20: .standard(proto: "free_asset_net_usage"),
    59: .standard(proto: "free_asset_net_usageV2"),
    21: .standard(proto: "latest_consume_time"),
    22: .standard(proto: "latest_consume_free_time"),
    23: .standard(proto: "account_id"),
    26: .standard(proto: "account_resource"),
    30: .same(proto: "codeHash"),
    31: .standard(proto: "owner_permission"),
    32: .standard(proto: "witness_permission"),
    33: .standard(proto: "active_permission"),
  ]

  fileprivate class _StorageClass {
    var _accountName: Data = SwiftProtobuf.Internal.emptyData
    var _type: Protocol_AccountType = .normal
    var _address: Data = SwiftProtobuf.Internal.emptyData
    var _balance: Int64 = 0
    var _votes: [Protocol_Vote] = []
    var _asset: Dictionary<String,Int64> = [:]
    var _assetV2: Dictionary<String,Int64> = [:]
    var _frozen: [Protocol_Account.Frozen] = []
    var _netUsage: Int64 = 0
    var _acquiredDelegatedFrozenBalanceForBandwidth: Int64 = 0
    var _delegatedFrozenBalanceForBandwidth: Int64 = 0
    var _createTime: Int64 = 0
    var _latestOprationTime: Int64 = 0
    var _allowance: Int64 = 0
    var _latestWithdrawTime: Int64 = 0
    var _code: Data = SwiftProtobuf.Internal.emptyData
    var _isWitness: Bool = false
    var _isCommittee: Bool = false
    var _frozenSupply: [Protocol_Account.Frozen] = []
    var _assetIssuedName: Data = SwiftProtobuf.Internal.emptyData
    var _assetIssuedID: Data = SwiftProtobuf.Internal.emptyData
    var _latestAssetOperationTime: Dictionary<String,Int64> = [:]
    var _latestAssetOperationTimeV2: Dictionary<String,Int64> = [:]
    var _freeNetUsage: Int64 = 0
    var _freeAssetNetUsage: Dictionary<String,Int64> = [:]
    var _freeAssetNetUsageV2: Dictionary<String,Int64> = [:]
    var _latestConsumeTime: Int64 = 0
    var _latestConsumeFreeTime: Int64 = 0
    var _accountID: Data = SwiftProtobuf.Internal.emptyData
    var _accountResource: Protocol_Account.AccountResource? = nil
    var _codeHash: Data = SwiftProtobuf.Internal.emptyData
    var _ownerPermission: Protocol_Permission? = nil
    var _witnessPermission: Protocol_Permission? = nil
    var _activePermission: [Protocol_Permission] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _accountName = source._accountName
      _type = source._type
      _address = source._address
      _balance = source._balance
      _votes = source._votes
      _asset = source._asset
      _assetV2 = source._assetV2
      _frozen = source._frozen
      _netUsage = source._netUsage
      _acquiredDelegatedFrozenBalanceForBandwidth = source._acquiredDelegatedFrozenBalanceForBandwidth
      _delegatedFrozenBalanceForBandwidth = source._delegatedFrozenBalanceForBandwidth
      _createTime = source._createTime
      _latestOprationTime = source._latestOprationTime
      _allowance = source._allowance
      _latestWithdrawTime = source._latestWithdrawTime
      _code = source._code
      _isWitness = source._isWitness
      _isCommittee = source._isCommittee
      _frozenSupply = source._frozenSupply
      _assetIssuedName = source._assetIssuedName
      _assetIssuedID = source._assetIssuedID
      _latestAssetOperationTime = source._latestAssetOperationTime
      _latestAssetOperationTimeV2 = source._latestAssetOperationTimeV2
      _freeNetUsage = source._freeNetUsage
      _freeAssetNetUsage = source._freeAssetNetUsage
      _freeAssetNetUsageV2 = source._freeAssetNetUsageV2
      _latestConsumeTime = source._latestConsumeTime
      _latestConsumeFreeTime = source._latestConsumeFreeTime
      _accountID = source._accountID
      _accountResource = source._accountResource
      _codeHash = source._codeHash
      _ownerPermission = source._ownerPermission
      _witnessPermission = source._witnessPermission
      _activePermission = source._activePermission
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._accountName)
        case 2: try decoder.decodeSingularEnumField(value: &_storage._type)
        case 3: try decoder.decodeSingularBytesField(value: &_storage._address)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._balance)
        case 5: try decoder.decodeRepeatedMessageField(value: &_storage._votes)
        case 6: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._asset)
        case 7: try decoder.decodeRepeatedMessageField(value: &_storage._frozen)
        case 8: try decoder.decodeSingularInt64Field(value: &_storage._netUsage)
        case 9: try decoder.decodeSingularInt64Field(value: &_storage._createTime)
        case 10: try decoder.decodeSingularInt64Field(value: &_storage._latestOprationTime)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._allowance)
        case 12: try decoder.decodeSingularInt64Field(value: &_storage._latestWithdrawTime)
        case 13: try decoder.decodeSingularBytesField(value: &_storage._code)
        case 14: try decoder.decodeSingularBoolField(value: &_storage._isWitness)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._isCommittee)
        case 16: try decoder.decodeRepeatedMessageField(value: &_storage._frozenSupply)
        case 17: try decoder.decodeSingularBytesField(value: &_storage._assetIssuedName)
        case 18: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._latestAssetOperationTime)
        case 19: try decoder.decodeSingularInt64Field(value: &_storage._freeNetUsage)
        case 20: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._freeAssetNetUsage)
        case 21: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeTime)
        case 22: try decoder.decodeSingularInt64Field(value: &_storage._latestConsumeFreeTime)
        case 23: try decoder.decodeSingularBytesField(value: &_storage._accountID)
        case 26: try decoder.decodeSingularMessageField(value: &_storage._accountResource)
        case 30: try decoder.decodeSingularBytesField(value: &_storage._codeHash)
        case 31: try decoder.decodeSingularMessageField(value: &_storage._ownerPermission)
        case 32: try decoder.decodeSingularMessageField(value: &_storage._witnessPermission)
        case 33: try decoder.decodeRepeatedMessageField(value: &_storage._activePermission)
        case 41: try decoder.decodeSingularInt64Field(value: &_storage._acquiredDelegatedFrozenBalanceForBandwidth)
        case 42: try decoder.decodeSingularInt64Field(value: &_storage._delegatedFrozenBalanceForBandwidth)
        case 56: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._assetV2)
        case 57: try decoder.decodeSingularBytesField(value: &_storage._assetIssuedID)
        case 58: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._latestAssetOperationTimeV2)
        case 59: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: &_storage._freeAssetNetUsageV2)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._accountName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountName, fieldNumber: 1)
      }
      if _storage._type != .normal {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 2)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._address, fieldNumber: 3)
      }
      if _storage._balance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._balance, fieldNumber: 4)
      }
      if !_storage._votes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._votes, fieldNumber: 5)
      }
      if !_storage._asset.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._asset, fieldNumber: 6)
      }
      if !_storage._frozen.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozen, fieldNumber: 7)
      }
      if _storage._netUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._netUsage, fieldNumber: 8)
      }
      if _storage._createTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._createTime, fieldNumber: 9)
      }
      if _storage._latestOprationTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestOprationTime, fieldNumber: 10)
      }
      if _storage._allowance != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowance, fieldNumber: 11)
      }
      if _storage._latestWithdrawTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestWithdrawTime, fieldNumber: 12)
      }
      if !_storage._code.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._code, fieldNumber: 13)
      }
      if _storage._isWitness != false {
        try visitor.visitSingularBoolField(value: _storage._isWitness, fieldNumber: 14)
      }
      if _storage._isCommittee != false {
        try visitor.visitSingularBoolField(value: _storage._isCommittee, fieldNumber: 15)
      }
      if !_storage._frozenSupply.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._frozenSupply, fieldNumber: 16)
      }
      if !_storage._assetIssuedName.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._assetIssuedName, fieldNumber: 17)
      }
      if !_storage._latestAssetOperationTime.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._latestAssetOperationTime, fieldNumber: 18)
      }
      if _storage._freeNetUsage != 0 {
        try visitor.visitSingularInt64Field(value: _storage._freeNetUsage, fieldNumber: 19)
      }
      if !_storage._freeAssetNetUsage.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._freeAssetNetUsage, fieldNumber: 20)
      }
      if _storage._latestConsumeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeTime, fieldNumber: 21)
      }
      if _storage._latestConsumeFreeTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._latestConsumeFreeTime, fieldNumber: 22)
      }
      if !_storage._accountID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._accountID, fieldNumber: 23)
      }
      if let v = _storage._accountResource {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }
      if !_storage._codeHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._codeHash, fieldNumber: 30)
      }
      if let v = _storage._ownerPermission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }
      if let v = _storage._witnessPermission {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }
      if !_storage._activePermission.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._activePermission, fieldNumber: 33)
      }
      if _storage._acquiredDelegatedFrozenBalanceForBandwidth != 0 {
        try visitor.visitSingularInt64Field(value: _storage._acquiredDelegatedFrozenBalanceForBandwidth, fieldNumber: 41)
      }
      if _storage._delegatedFrozenBalanceForBandwidth != 0 {
        try visitor.visitSingularInt64Field(value: _storage._delegatedFrozenBalanceForBandwidth, fieldNumber: 42)
      }
      if !_storage._assetV2.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._assetV2, fieldNumber: 56)
      }
      if !_storage._assetIssuedID.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._assetIssuedID, fieldNumber: 57)
      }
      if !_storage._latestAssetOperationTimeV2.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._latestAssetOperationTimeV2, fieldNumber: 58)
      }
      if !_storage._freeAssetNetUsageV2.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufInt64>.self, value: _storage._freeAssetNetUsageV2, fieldNumber: 59)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account, rhs: Protocol_Account) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._accountName != rhs_storage._accountName {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._balance != rhs_storage._balance {return false}
        if _storage._votes != rhs_storage._votes {return false}
        if _storage._asset != rhs_storage._asset {return false}
        if _storage._assetV2 != rhs_storage._assetV2 {return false}
        if _storage._frozen != rhs_storage._frozen {return false}
        if _storage._netUsage != rhs_storage._netUsage {return false}
        if _storage._acquiredDelegatedFrozenBalanceForBandwidth != rhs_storage._acquiredDelegatedFrozenBalanceForBandwidth {return false}
        if _storage._delegatedFrozenBalanceForBandwidth != rhs_storage._delegatedFrozenBalanceForBandwidth {return false}
        if _storage._createTime != rhs_storage._createTime {return false}
        if _storage._latestOprationTime != rhs_storage._latestOprationTime {return false}
        if _storage._allowance != rhs_storage._allowance {return false}
        if _storage._latestWithdrawTime != rhs_storage._latestWithdrawTime {return false}
        if _storage._code != rhs_storage._code {return false}
        if _storage._isWitness != rhs_storage._isWitness {return false}
        if _storage._isCommittee != rhs_storage._isCommittee {return false}
        if _storage._frozenSupply != rhs_storage._frozenSupply {return false}
        if _storage._assetIssuedName != rhs_storage._assetIssuedName {return false}
        if _storage._assetIssuedID != rhs_storage._assetIssuedID {return false}
        if _storage._latestAssetOperationTime != rhs_storage._latestAssetOperationTime {return false}
        if _storage._latestAssetOperationTimeV2 != rhs_storage._latestAssetOperationTimeV2 {return false}
        if _storage._freeNetUsage != rhs_storage._freeNetUsage {return false}
        if _storage._freeAssetNetUsage != rhs_storage._freeAssetNetUsage {return false}
        if _storage._freeAssetNetUsageV2 != rhs_storage._freeAssetNetUsageV2 {return false}
        if _storage._latestConsumeTime != rhs_storage._latestConsumeTime {return false}
        if _storage._latestConsumeFreeTime != rhs_storage._latestConsumeFreeTime {return false}
        if _storage._accountID != rhs_storage._accountID {return false}
        if _storage._accountResource != rhs_storage._accountResource {return false}
        if _storage._codeHash != rhs_storage._codeHash {return false}
        if _storage._ownerPermission != rhs_storage._ownerPermission {return false}
        if _storage._witnessPermission != rhs_storage._witnessPermission {return false}
        if _storage._activePermission != rhs_storage._activePermission {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.Frozen: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Account.protoMessageName + ".Frozen"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "frozen_balance"),
    2: .standard(proto: "expire_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.frozenBalance)
      case 2: try decoder.decodeSingularInt64Field(value: &self.expireTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.frozenBalance != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalance, fieldNumber: 1)
    }
    if self.expireTime != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTime, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account.Frozen, rhs: Protocol_Account.Frozen) -> Bool {
    if lhs.frozenBalance != rhs.frozenBalance {return false}
    if lhs.expireTime != rhs.expireTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Account.AccountResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Account.protoMessageName + ".AccountResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_usage"),
    2: .standard(proto: "frozen_balance_for_energy"),
    3: .standard(proto: "latest_consume_time_for_energy"),
    4: .standard(proto: "acquired_delegated_frozen_balance_for_energy"),
    5: .standard(proto: "delegated_frozen_balance_for_energy"),
    6: .standard(proto: "storage_limit"),
    7: .standard(proto: "storage_usage"),
    8: .standard(proto: "latest_exchange_storage_time"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.energyUsage)
      case 2: try decoder.decodeSingularMessageField(value: &self._frozenBalanceForEnergy)
      case 3: try decoder.decodeSingularInt64Field(value: &self.latestConsumeTimeForEnergy)
      case 4: try decoder.decodeSingularInt64Field(value: &self.acquiredDelegatedFrozenBalanceForEnergy)
      case 5: try decoder.decodeSingularInt64Field(value: &self.delegatedFrozenBalanceForEnergy)
      case 6: try decoder.decodeSingularInt64Field(value: &self.storageLimit)
      case 7: try decoder.decodeSingularInt64Field(value: &self.storageUsage)
      case 8: try decoder.decodeSingularInt64Field(value: &self.latestExchangeStorageTime)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.energyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsage, fieldNumber: 1)
    }
    if let v = self._frozenBalanceForEnergy {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.latestConsumeTimeForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.latestConsumeTimeForEnergy, fieldNumber: 3)
    }
    if self.acquiredDelegatedFrozenBalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.acquiredDelegatedFrozenBalanceForEnergy, fieldNumber: 4)
    }
    if self.delegatedFrozenBalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.delegatedFrozenBalanceForEnergy, fieldNumber: 5)
    }
    if self.storageLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.storageLimit, fieldNumber: 6)
    }
    if self.storageUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.storageUsage, fieldNumber: 7)
    }
    if self.latestExchangeStorageTime != 0 {
      try visitor.visitSingularInt64Field(value: self.latestExchangeStorageTime, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Account.AccountResource, rhs: Protocol_Account.AccountResource) -> Bool {
    if lhs.energyUsage != rhs.energyUsage {return false}
    if lhs._frozenBalanceForEnergy != rhs._frozenBalanceForEnergy {return false}
    if lhs.latestConsumeTimeForEnergy != rhs.latestConsumeTimeForEnergy {return false}
    if lhs.acquiredDelegatedFrozenBalanceForEnergy != rhs.acquiredDelegatedFrozenBalanceForEnergy {return false}
    if lhs.delegatedFrozenBalanceForEnergy != rhs.delegatedFrozenBalanceForEnergy {return false}
    if lhs.storageLimit != rhs.storageLimit {return false}
    if lhs.storageUsage != rhs.storageUsage {return false}
    if lhs.latestExchangeStorageTime != rhs.latestExchangeStorageTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Key"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "weight"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularInt64Field(value: &self.weight)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.weight != 0 {
      try visitor.visitSingularInt64Field(value: self.weight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Key, rhs: Protocol_Key) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.weight != rhs.weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DelegatedResource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedResource"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "frozen_balance_for_bandwidth"),
    4: .standard(proto: "frozen_balance_for_energy"),
    5: .standard(proto: "expire_time_for_bandwidth"),
    6: .standard(proto: "expire_time_for_energy"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularBytesField(value: &self.to)
      case 3: try decoder.decodeSingularInt64Field(value: &self.frozenBalanceForBandwidth)
      case 4: try decoder.decodeSingularInt64Field(value: &self.frozenBalanceForEnergy)
      case 5: try decoder.decodeSingularInt64Field(value: &self.expireTimeForBandwidth)
      case 6: try decoder.decodeSingularInt64Field(value: &self.expireTimeForEnergy)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    if self.frozenBalanceForBandwidth != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalanceForBandwidth, fieldNumber: 3)
    }
    if self.frozenBalanceForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.frozenBalanceForEnergy, fieldNumber: 4)
    }
    if self.expireTimeForBandwidth != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTimeForBandwidth, fieldNumber: 5)
    }
    if self.expireTimeForEnergy != 0 {
      try visitor.visitSingularInt64Field(value: self.expireTimeForEnergy, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DelegatedResource, rhs: Protocol_DelegatedResource) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.frozenBalanceForBandwidth != rhs.frozenBalanceForBandwidth {return false}
    if lhs.frozenBalanceForEnergy != rhs.frozenBalanceForEnergy {return false}
    if lhs.expireTimeForBandwidth != rhs.expireTimeForBandwidth {return false}
    if lhs.expireTimeForEnergy != rhs.expireTimeForEnergy {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_authority: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".authority"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .standard(proto: "permission_name"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._account)
      case 2: try decoder.decodeSingularBytesField(value: &self.permissionName)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._account {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.permissionName.isEmpty {
      try visitor.visitSingularBytesField(value: self.permissionName, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_authority, rhs: Protocol_authority) -> Bool {
    if lhs._account != rhs._account {return false}
    if lhs.permissionName != rhs.permissionName {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Permission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Permission"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "id"),
    3: .standard(proto: "permission_name"),
    4: .same(proto: "threshold"),
    5: .standard(proto: "parent_id"),
    6: .same(proto: "operations"),
    7: .same(proto: "keys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularInt32Field(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.permissionName)
      case 4: try decoder.decodeSingularInt64Field(value: &self.threshold)
      case 5: try decoder.decodeSingularInt32Field(value: &self.parentID)
      case 6: try decoder.decodeSingularBytesField(value: &self.operations)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.keys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .owner {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 2)
    }
    if !self.permissionName.isEmpty {
      try visitor.visitSingularStringField(value: self.permissionName, fieldNumber: 3)
    }
    if self.threshold != 0 {
      try visitor.visitSingularInt64Field(value: self.threshold, fieldNumber: 4)
    }
    if self.parentID != 0 {
      try visitor.visitSingularInt32Field(value: self.parentID, fieldNumber: 5)
    }
    if !self.operations.isEmpty {
      try visitor.visitSingularBytesField(value: self.operations, fieldNumber: 6)
    }
    if !self.keys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keys, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Permission, rhs: Protocol_Permission) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.id != rhs.id {return false}
    if lhs.permissionName != rhs.permissionName {return false}
    if lhs.threshold != rhs.threshold {return false}
    if lhs.parentID != rhs.parentID {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.keys != rhs.keys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Permission.PermissionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Owner"),
    1: .same(proto: "Witness"),
    2: .same(proto: "Active"),
  ]
}

extension Protocol_Witness: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Witness"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "voteCount"),
    3: .same(proto: "pubKey"),
    4: .same(proto: "url"),
    5: .same(proto: "totalProduced"),
    6: .same(proto: "totalMissed"),
    7: .same(proto: "latestBlockNum"),
    8: .same(proto: "latestSlotNum"),
    9: .same(proto: "isJobs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularInt64Field(value: &self.voteCount)
      case 3: try decoder.decodeSingularBytesField(value: &self.pubKey)
      case 4: try decoder.decodeSingularStringField(value: &self.url)
      case 5: try decoder.decodeSingularInt64Field(value: &self.totalProduced)
      case 6: try decoder.decodeSingularInt64Field(value: &self.totalMissed)
      case 7: try decoder.decodeSingularInt64Field(value: &self.latestBlockNum)
      case 8: try decoder.decodeSingularInt64Field(value: &self.latestSlotNum)
      case 9: try decoder.decodeSingularBoolField(value: &self.isJobs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.voteCount != 0 {
      try visitor.visitSingularInt64Field(value: self.voteCount, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 4)
    }
    if self.totalProduced != 0 {
      try visitor.visitSingularInt64Field(value: self.totalProduced, fieldNumber: 5)
    }
    if self.totalMissed != 0 {
      try visitor.visitSingularInt64Field(value: self.totalMissed, fieldNumber: 6)
    }
    if self.latestBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.latestBlockNum, fieldNumber: 7)
    }
    if self.latestSlotNum != 0 {
      try visitor.visitSingularInt64Field(value: self.latestSlotNum, fieldNumber: 8)
    }
    if self.isJobs != false {
      try visitor.visitSingularBoolField(value: self.isJobs, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Witness, rhs: Protocol_Witness) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.voteCount != rhs.voteCount {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.url != rhs.url {return false}
    if lhs.totalProduced != rhs.totalProduced {return false}
    if lhs.totalMissed != rhs.totalMissed {return false}
    if lhs.latestBlockNum != rhs.latestBlockNum {return false}
    if lhs.latestSlotNum != rhs.latestSlotNum {return false}
    if lhs.isJobs != rhs.isJobs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Votes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Votes"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .standard(proto: "old_votes"),
    3: .standard(proto: "new_votes"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.oldVotes)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.newVotes)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.oldVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.oldVotes, fieldNumber: 2)
    }
    if !self.newVotes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.newVotes, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Votes, rhs: Protocol_Votes) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.oldVotes != rhs.oldVotes {return false}
    if lhs.newVotes != rhs.newVotes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TXOutput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "value"),
    2: .same(proto: "pubKeyHash"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.value)
      case 2: try decoder.decodeSingularBytesField(value: &self.pubKeyHash)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.value != 0 {
      try visitor.visitSingularInt64Field(value: self.value, fieldNumber: 1)
    }
    if !self.pubKeyHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKeyHash, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXOutput, rhs: Protocol_TXOutput) -> Bool {
    if lhs.value != rhs.value {return false}
    if lhs.pubKeyHash != rhs.pubKeyHash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TXInput"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    4: .same(proto: "signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._rawData)
      case 4: try decoder.decodeSingularBytesField(value: &self.signature)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXInput, rhs: Protocol_TXInput) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXInput.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_TXInput.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txID"),
    2: .same(proto: "vout"),
    3: .same(proto: "pubKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.txID)
      case 2: try decoder.decodeSingularInt64Field(value: &self.vout)
      case 3: try decoder.decodeSingularBytesField(value: &self.pubKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txID.isEmpty {
      try visitor.visitSingularBytesField(value: self.txID, fieldNumber: 1)
    }
    if self.vout != 0 {
      try visitor.visitSingularInt64Field(value: self.vout, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXInput.raw, rhs: Protocol_TXInput.raw) -> Bool {
    if lhs.txID != rhs.txID {return false}
    if lhs.vout != rhs.vout {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TXOutputs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TXOutputs"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outputs"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TXOutputs, rhs: Protocol_TXOutputs) -> Bool {
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ResourceReceipt: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ResourceReceipt"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "energy_usage"),
    2: .standard(proto: "energy_fee"),
    3: .standard(proto: "origin_energy_usage"),
    4: .standard(proto: "energy_usage_total"),
    5: .standard(proto: "net_usage"),
    6: .standard(proto: "net_fee"),
    7: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.energyUsage)
      case 2: try decoder.decodeSingularInt64Field(value: &self.energyFee)
      case 3: try decoder.decodeSingularInt64Field(value: &self.originEnergyUsage)
      case 4: try decoder.decodeSingularInt64Field(value: &self.energyUsageTotal)
      case 5: try decoder.decodeSingularInt64Field(value: &self.netUsage)
      case 6: try decoder.decodeSingularInt64Field(value: &self.netFee)
      case 7: try decoder.decodeSingularEnumField(value: &self.result)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.energyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsage, fieldNumber: 1)
    }
    if self.energyFee != 0 {
      try visitor.visitSingularInt64Field(value: self.energyFee, fieldNumber: 2)
    }
    if self.originEnergyUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.originEnergyUsage, fieldNumber: 3)
    }
    if self.energyUsageTotal != 0 {
      try visitor.visitSingularInt64Field(value: self.energyUsageTotal, fieldNumber: 4)
    }
    if self.netUsage != 0 {
      try visitor.visitSingularInt64Field(value: self.netUsage, fieldNumber: 5)
    }
    if self.netFee != 0 {
      try visitor.visitSingularInt64Field(value: self.netFee, fieldNumber: 6)
    }
    if self.result != .default {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ResourceReceipt, rhs: Protocol_ResourceReceipt) -> Bool {
    if lhs.energyUsage != rhs.energyUsage {return false}
    if lhs.energyFee != rhs.energyFee {return false}
    if lhs.originEnergyUsage != rhs.originEnergyUsage {return false}
    if lhs.energyUsageTotal != rhs.energyUsageTotal {return false}
    if lhs.netUsage != rhs.netUsage {return false}
    if lhs.netFee != rhs.netFee {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .same(proto: "signature"),
    5: .same(proto: "ret"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._rawData)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.signature)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.ret)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signature, fieldNumber: 2)
    }
    if !self.ret.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ret, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction, rhs: Protocol_Transaction) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Contract"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "parameter"),
    3: .same(proto: "provider"),
    4: .same(proto: "ContractName"),
    5: .standard(proto: "Permission_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeSingularMessageField(value: &self._parameter)
      case 3: try decoder.decodeSingularBytesField(value: &self.provider)
      case 4: try decoder.decodeSingularBytesField(value: &self.contractName)
      case 5: try decoder.decodeSingularInt32Field(value: &self.permissionID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .accountCreateContract {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if let v = self._parameter {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.provider.isEmpty {
      try visitor.visitSingularBytesField(value: self.provider, fieldNumber: 3)
    }
    if !self.contractName.isEmpty {
      try visitor.visitSingularBytesField(value: self.contractName, fieldNumber: 4)
    }
    if self.permissionID != 0 {
      try visitor.visitSingularInt32Field(value: self.permissionID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction.Contract, rhs: Protocol_Transaction.Contract) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._parameter != rhs._parameter {return false}
    if lhs.provider != rhs.provider {return false}
    if lhs.contractName != rhs.contractName {return false}
    if lhs.permissionID != rhs.permissionID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Contract.ContractType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "AccountCreateContract"),
    1: .same(proto: "TransferContract"),
    2: .same(proto: "TransferAssetContract"),
    3: .same(proto: "VoteAssetContract"),
    4: .same(proto: "VoteWitnessContract"),
    5: .same(proto: "WitnessCreateContract"),
    6: .same(proto: "AssetIssueContract"),
    8: .same(proto: "WitnessUpdateContract"),
    9: .same(proto: "ParticipateAssetIssueContract"),
    10: .same(proto: "AccountUpdateContract"),
    11: .same(proto: "FreezeBalanceContract"),
    12: .same(proto: "UnfreezeBalanceContract"),
    13: .same(proto: "WithdrawBalanceContract"),
    14: .same(proto: "UnfreezeAssetContract"),
    15: .same(proto: "UpdateAssetContract"),
    16: .same(proto: "ProposalCreateContract"),
    17: .same(proto: "ProposalApproveContract"),
    18: .same(proto: "ProposalDeleteContract"),
    19: .same(proto: "SetAccountIdContract"),
    20: .same(proto: "CustomContract"),
    30: .same(proto: "CreateSmartContract"),
    31: .same(proto: "TriggerSmartContract"),
    32: .same(proto: "GetContract"),
    33: .same(proto: "UpdateSettingContract"),
    41: .same(proto: "ExchangeCreateContract"),
    42: .same(proto: "ExchangeInjectContract"),
    43: .same(proto: "ExchangeWithdrawContract"),
    44: .same(proto: "ExchangeTransactionContract"),
    45: .same(proto: "UpdateEnergyLimitContract"),
    46: .same(proto: "AccountPermissionUpdateContract"),
    48: .same(proto: "ClearABIContract"),
    49: .same(proto: "UpdateBrokerageContract"),
    51: .same(proto: "ShieldedTransferContract"),
  ]
}

extension Protocol_Transaction.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".Result"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fee"),
    2: .same(proto: "ret"),
    3: .same(proto: "contractRet"),
    14: .same(proto: "assetIssueID"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
    18: .standard(proto: "exchange_received_amount"),
    19: .standard(proto: "exchange_inject_another_amount"),
    20: .standard(proto: "exchange_withdraw_another_amount"),
    21: .standard(proto: "exchange_id"),
    22: .standard(proto: "shielded_transaction_fee"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.fee)
      case 2: try decoder.decodeSingularEnumField(value: &self.ret)
      case 3: try decoder.decodeSingularEnumField(value: &self.contractRet)
      case 14: try decoder.decodeSingularStringField(value: &self.assetIssueID)
      case 15: try decoder.decodeSingularInt64Field(value: &self.withdrawAmount)
      case 16: try decoder.decodeSingularInt64Field(value: &self.unfreezeAmount)
      case 18: try decoder.decodeSingularInt64Field(value: &self.exchangeReceivedAmount)
      case 19: try decoder.decodeSingularInt64Field(value: &self.exchangeInjectAnotherAmount)
      case 20: try decoder.decodeSingularInt64Field(value: &self.exchangeWithdrawAnotherAmount)
      case 21: try decoder.decodeSingularInt64Field(value: &self.exchangeID)
      case 22: try decoder.decodeSingularInt64Field(value: &self.shieldedTransactionFee)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fee != 0 {
      try visitor.visitSingularInt64Field(value: self.fee, fieldNumber: 1)
    }
    if self.ret != .sucess {
      try visitor.visitSingularEnumField(value: self.ret, fieldNumber: 2)
    }
    if self.contractRet != .default {
      try visitor.visitSingularEnumField(value: self.contractRet, fieldNumber: 3)
    }
    if !self.assetIssueID.isEmpty {
      try visitor.visitSingularStringField(value: self.assetIssueID, fieldNumber: 14)
    }
    if self.withdrawAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.withdrawAmount, fieldNumber: 15)
    }
    if self.unfreezeAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.unfreezeAmount, fieldNumber: 16)
    }
    if self.exchangeReceivedAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeReceivedAmount, fieldNumber: 18)
    }
    if self.exchangeInjectAnotherAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeInjectAnotherAmount, fieldNumber: 19)
    }
    if self.exchangeWithdrawAnotherAmount != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeWithdrawAnotherAmount, fieldNumber: 20)
    }
    if self.exchangeID != 0 {
      try visitor.visitSingularInt64Field(value: self.exchangeID, fieldNumber: 21)
    }
    if self.shieldedTransactionFee != 0 {
      try visitor.visitSingularInt64Field(value: self.shieldedTransactionFee, fieldNumber: 22)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction.Result, rhs: Protocol_Transaction.Result) -> Bool {
    if lhs.fee != rhs.fee {return false}
    if lhs.ret != rhs.ret {return false}
    if lhs.contractRet != rhs.contractRet {return false}
    if lhs.assetIssueID != rhs.assetIssueID {return false}
    if lhs.withdrawAmount != rhs.withdrawAmount {return false}
    if lhs.unfreezeAmount != rhs.unfreezeAmount {return false}
    if lhs.exchangeReceivedAmount != rhs.exchangeReceivedAmount {return false}
    if lhs.exchangeInjectAnotherAmount != rhs.exchangeInjectAnotherAmount {return false}
    if lhs.exchangeWithdrawAnotherAmount != rhs.exchangeWithdrawAnotherAmount {return false}
    if lhs.exchangeID != rhs.exchangeID {return false}
    if lhs.shieldedTransactionFee != rhs.shieldedTransactionFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transaction.Result.code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_Transaction.Result.contractResult: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DEFAULT"),
    1: .same(proto: "SUCCESS"),
    2: .same(proto: "REVERT"),
    3: .same(proto: "BAD_JUMP_DESTINATION"),
    4: .same(proto: "OUT_OF_MEMORY"),
    5: .same(proto: "PRECOMPILED_CONTRACT"),
    6: .same(proto: "STACK_TOO_SMALL"),
    7: .same(proto: "STACK_TOO_LARGE"),
    8: .same(proto: "ILLEGAL_OPERATION"),
    9: .same(proto: "STACK_OVERFLOW"),
    10: .same(proto: "OUT_OF_ENERGY"),
    11: .same(proto: "OUT_OF_TIME"),
    12: .same(proto: "JVM_STACK_OVER_FLOW"),
    13: .same(proto: "UNKNOWN"),
    14: .same(proto: "TRANSFER_FAILED"),
  ]
}

extension Protocol_Transaction.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_Transaction.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ref_block_bytes"),
    3: .standard(proto: "ref_block_num"),
    4: .standard(proto: "ref_block_hash"),
    8: .same(proto: "expiration"),
    9: .same(proto: "auths"),
    10: .same(proto: "data"),
    11: .same(proto: "contract"),
    12: .same(proto: "scripts"),
    14: .same(proto: "timestamp"),
    18: .standard(proto: "fee_limit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.refBlockBytes)
      case 3: try decoder.decodeSingularInt64Field(value: &self.refBlockNum)
      case 4: try decoder.decodeSingularBytesField(value: &self.refBlockHash)
      case 8: try decoder.decodeSingularInt64Field(value: &self.expiration)
      case 9: try decoder.decodeRepeatedMessageField(value: &self.auths)
      case 10: try decoder.decodeSingularBytesField(value: &self.data)
      case 11: try decoder.decodeRepeatedMessageField(value: &self.contract)
      case 12: try decoder.decodeSingularBytesField(value: &self.scripts)
      case 14: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 18: try decoder.decodeSingularInt64Field(value: &self.feeLimit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.refBlockBytes.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockBytes, fieldNumber: 1)
    }
    if self.refBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.refBlockNum, fieldNumber: 3)
    }
    if !self.refBlockHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.refBlockHash, fieldNumber: 4)
    }
    if self.expiration != 0 {
      try visitor.visitSingularInt64Field(value: self.expiration, fieldNumber: 8)
    }
    if !self.auths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auths, fieldNumber: 9)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 10)
    }
    if !self.contract.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contract, fieldNumber: 11)
    }
    if !self.scripts.isEmpty {
      try visitor.visitSingularBytesField(value: self.scripts, fieldNumber: 12)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 14)
    }
    if self.feeLimit != 0 {
      try visitor.visitSingularInt64Field(value: self.feeLimit, fieldNumber: 18)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transaction.raw, rhs: Protocol_Transaction.raw) -> Bool {
    if lhs.refBlockBytes != rhs.refBlockBytes {return false}
    if lhs.refBlockNum != rhs.refBlockNum {return false}
    if lhs.refBlockHash != rhs.refBlockHash {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.auths != rhs.auths {return false}
    if lhs.data != rhs.data {return false}
    if lhs.contract != rhs.contract {return false}
    if lhs.scripts != rhs.scripts {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "fee"),
    3: .same(proto: "blockNumber"),
    4: .same(proto: "blockTimeStamp"),
    5: .same(proto: "contractResult"),
    6: .standard(proto: "contract_address"),
    7: .same(proto: "receipt"),
    8: .same(proto: "log"),
    9: .same(proto: "result"),
    10: .same(proto: "resMessage"),
    14: .same(proto: "assetIssueID"),
    15: .standard(proto: "withdraw_amount"),
    16: .standard(proto: "unfreeze_amount"),
    17: .standard(proto: "internal_transactions"),
    18: .standard(proto: "exchange_received_amount"),
    19: .standard(proto: "exchange_inject_another_amount"),
    20: .standard(proto: "exchange_withdraw_another_amount"),
    21: .standard(proto: "exchange_id"),
    22: .standard(proto: "shielded_transaction_fee"),
  ]

  fileprivate class _StorageClass {
    var _id: Data = SwiftProtobuf.Internal.emptyData
    var _fee: Int64 = 0
    var _blockNumber: Int64 = 0
    var _blockTimeStamp: Int64 = 0
    var _contractResult: [Data] = []
    var _contractAddress: Data = SwiftProtobuf.Internal.emptyData
    var _receipt: Protocol_ResourceReceipt? = nil
    var _log: [Protocol_TransactionInfo.Log] = []
    var _result: Protocol_TransactionInfo.code = .sucess
    var _resMessage: Data = SwiftProtobuf.Internal.emptyData
    var _assetIssueID: String = String()
    var _withdrawAmount: Int64 = 0
    var _unfreezeAmount: Int64 = 0
    var _internalTransactions: [Protocol_InternalTransaction] = []
    var _exchangeReceivedAmount: Int64 = 0
    var _exchangeInjectAnotherAmount: Int64 = 0
    var _exchangeWithdrawAnotherAmount: Int64 = 0
    var _exchangeID: Int64 = 0
    var _shieldedTransactionFee: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _fee = source._fee
      _blockNumber = source._blockNumber
      _blockTimeStamp = source._blockTimeStamp
      _contractResult = source._contractResult
      _contractAddress = source._contractAddress
      _receipt = source._receipt
      _log = source._log
      _result = source._result
      _resMessage = source._resMessage
      _assetIssueID = source._assetIssueID
      _withdrawAmount = source._withdrawAmount
      _unfreezeAmount = source._unfreezeAmount
      _internalTransactions = source._internalTransactions
      _exchangeReceivedAmount = source._exchangeReceivedAmount
      _exchangeInjectAnotherAmount = source._exchangeInjectAnotherAmount
      _exchangeWithdrawAnotherAmount = source._exchangeWithdrawAnotherAmount
      _exchangeID = source._exchangeID
      _shieldedTransactionFee = source._shieldedTransactionFee
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularBytesField(value: &_storage._id)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._fee)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._blockNumber)
        case 4: try decoder.decodeSingularInt64Field(value: &_storage._blockTimeStamp)
        case 5: try decoder.decodeRepeatedBytesField(value: &_storage._contractResult)
        case 6: try decoder.decodeSingularBytesField(value: &_storage._contractAddress)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._receipt)
        case 8: try decoder.decodeRepeatedMessageField(value: &_storage._log)
        case 9: try decoder.decodeSingularEnumField(value: &_storage._result)
        case 10: try decoder.decodeSingularBytesField(value: &_storage._resMessage)
        case 14: try decoder.decodeSingularStringField(value: &_storage._assetIssueID)
        case 15: try decoder.decodeSingularInt64Field(value: &_storage._withdrawAmount)
        case 16: try decoder.decodeSingularInt64Field(value: &_storage._unfreezeAmount)
        case 17: try decoder.decodeRepeatedMessageField(value: &_storage._internalTransactions)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._exchangeReceivedAmount)
        case 19: try decoder.decodeSingularInt64Field(value: &_storage._exchangeInjectAnotherAmount)
        case 20: try decoder.decodeSingularInt64Field(value: &_storage._exchangeWithdrawAnotherAmount)
        case 21: try decoder.decodeSingularInt64Field(value: &_storage._exchangeID)
        case 22: try decoder.decodeSingularInt64Field(value: &_storage._shieldedTransactionFee)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._id.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._id, fieldNumber: 1)
      }
      if _storage._fee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._fee, fieldNumber: 2)
      }
      if _storage._blockNumber != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockNumber, fieldNumber: 3)
      }
      if _storage._blockTimeStamp != 0 {
        try visitor.visitSingularInt64Field(value: _storage._blockTimeStamp, fieldNumber: 4)
      }
      if !_storage._contractResult.isEmpty {
        try visitor.visitRepeatedBytesField(value: _storage._contractResult, fieldNumber: 5)
      }
      if !_storage._contractAddress.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._contractAddress, fieldNumber: 6)
      }
      if let v = _storage._receipt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if !_storage._log.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._log, fieldNumber: 8)
      }
      if _storage._result != .sucess {
        try visitor.visitSingularEnumField(value: _storage._result, fieldNumber: 9)
      }
      if !_storage._resMessage.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._resMessage, fieldNumber: 10)
      }
      if !_storage._assetIssueID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._assetIssueID, fieldNumber: 14)
      }
      if _storage._withdrawAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._withdrawAmount, fieldNumber: 15)
      }
      if _storage._unfreezeAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unfreezeAmount, fieldNumber: 16)
      }
      if !_storage._internalTransactions.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._internalTransactions, fieldNumber: 17)
      }
      if _storage._exchangeReceivedAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeReceivedAmount, fieldNumber: 18)
      }
      if _storage._exchangeInjectAnotherAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeInjectAnotherAmount, fieldNumber: 19)
      }
      if _storage._exchangeWithdrawAnotherAmount != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeWithdrawAnotherAmount, fieldNumber: 20)
      }
      if _storage._exchangeID != 0 {
        try visitor.visitSingularInt64Field(value: _storage._exchangeID, fieldNumber: 21)
      }
      if _storage._shieldedTransactionFee != 0 {
        try visitor.visitSingularInt64Field(value: _storage._shieldedTransactionFee, fieldNumber: 22)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionInfo, rhs: Protocol_TransactionInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._fee != rhs_storage._fee {return false}
        if _storage._blockNumber != rhs_storage._blockNumber {return false}
        if _storage._blockTimeStamp != rhs_storage._blockTimeStamp {return false}
        if _storage._contractResult != rhs_storage._contractResult {return false}
        if _storage._contractAddress != rhs_storage._contractAddress {return false}
        if _storage._receipt != rhs_storage._receipt {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._resMessage != rhs_storage._resMessage {return false}
        if _storage._assetIssueID != rhs_storage._assetIssueID {return false}
        if _storage._withdrawAmount != rhs_storage._withdrawAmount {return false}
        if _storage._unfreezeAmount != rhs_storage._unfreezeAmount {return false}
        if _storage._internalTransactions != rhs_storage._internalTransactions {return false}
        if _storage._exchangeReceivedAmount != rhs_storage._exchangeReceivedAmount {return false}
        if _storage._exchangeInjectAnotherAmount != rhs_storage._exchangeInjectAnotherAmount {return false}
        if _storage._exchangeWithdrawAnotherAmount != rhs_storage._exchangeWithdrawAnotherAmount {return false}
        if _storage._exchangeID != rhs_storage._exchangeID {return false}
        if _storage._shieldedTransactionFee != rhs_storage._shieldedTransactionFee {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionInfo.code: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SUCESS"),
    1: .same(proto: "FAILED"),
  ]
}

extension Protocol_TransactionInfo.Log: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_TransactionInfo.protoMessageName + ".Log"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "topics"),
    3: .same(proto: "data"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.topics)
      case 3: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.topics.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.topics, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionInfo.Log, rhs: Protocol_TransactionInfo.Log) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.topics != rhs.topics {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionRet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionRet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blockNumber"),
    2: .same(proto: "blockTimeStamp"),
    3: .same(proto: "transactioninfo"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.blockNumber)
      case 2: try decoder.decodeSingularInt64Field(value: &self.blockTimeStamp)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.transactioninfo)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.blockNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.blockNumber, fieldNumber: 1)
    }
    if self.blockTimeStamp != 0 {
      try visitor.visitSingularInt64Field(value: self.blockTimeStamp, fieldNumber: 2)
    }
    if !self.transactioninfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactioninfo, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionRet, rhs: Protocol_TransactionRet) -> Bool {
    if lhs.blockNumber != rhs.blockNumber {return false}
    if lhs.blockTimeStamp != rhs.blockTimeStamp {return false}
    if lhs.transactioninfo != rhs.transactioninfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Transactions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Transactions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Transactions, rhs: Protocol_Transactions) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_TransactionSign: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".TransactionSign"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transaction"),
    2: .same(proto: "privateKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._transaction)
      case 2: try decoder.decodeSingularBytesField(value: &self.privateKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._transaction {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.privateKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.privateKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_TransactionSign, rhs: Protocol_TransactionSign) -> Bool {
    if lhs._transaction != rhs._transaction {return false}
    if lhs.privateKey != rhs.privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockHeader"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_data"),
    2: .standard(proto: "witness_signature"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._rawData)
      case 2: try decoder.decodeSingularBytesField(value: &self.witnessSignature)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._rawData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.witnessSignature.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessSignature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockHeader, rhs: Protocol_BlockHeader) -> Bool {
    if lhs._rawData != rhs._rawData {return false}
    if lhs.witnessSignature != rhs.witnessSignature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockHeader.raw: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_BlockHeader.protoMessageName + ".raw"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "txTrieRoot"),
    3: .same(proto: "parentHash"),
    7: .same(proto: "number"),
    8: .standard(proto: "witness_id"),
    9: .standard(proto: "witness_address"),
    10: .same(proto: "version"),
    11: .same(proto: "accountStateRoot"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 2: try decoder.decodeSingularBytesField(value: &self.txTrieRoot)
      case 3: try decoder.decodeSingularBytesField(value: &self.parentHash)
      case 7: try decoder.decodeSingularInt64Field(value: &self.number)
      case 8: try decoder.decodeSingularInt64Field(value: &self.witnessID)
      case 9: try decoder.decodeSingularBytesField(value: &self.witnessAddress)
      case 10: try decoder.decodeSingularInt32Field(value: &self.version)
      case 11: try decoder.decodeSingularBytesField(value: &self.accountStateRoot)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 1)
    }
    if !self.txTrieRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.txTrieRoot, fieldNumber: 2)
    }
    if !self.parentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.parentHash, fieldNumber: 3)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 7)
    }
    if self.witnessID != 0 {
      try visitor.visitSingularInt64Field(value: self.witnessID, fieldNumber: 8)
    }
    if !self.witnessAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.witnessAddress, fieldNumber: 9)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 10)
    }
    if !self.accountStateRoot.isEmpty {
      try visitor.visitSingularBytesField(value: self.accountStateRoot, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockHeader.raw, rhs: Protocol_BlockHeader.raw) -> Bool {
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.txTrieRoot != rhs.txTrieRoot {return false}
    if lhs.parentHash != rhs.parentHash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.witnessID != rhs.witnessID {return false}
    if lhs.witnessAddress != rhs.witnessAddress {return false}
    if lhs.version != rhs.version {return false}
    if lhs.accountStateRoot != rhs.accountStateRoot {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Block: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Block"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "transactions"),
    2: .standard(proto: "block_header"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      case 2: try decoder.decodeSingularMessageField(value: &self._blockHeader)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 1)
    }
    if let v = self._blockHeader {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Block, rhs: Protocol_Block) -> Bool {
    if lhs.transactions != rhs.transactions {return false}
    if lhs._blockHeader != rhs._blockHeader {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ChainInventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .standard(proto: "remain_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ids)
      case 2: try decoder.decodeSingularInt64Field(value: &self.remainNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if self.remainNum != 0 {
      try visitor.visitSingularInt64Field(value: self.remainNum, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainInventory, rhs: Protocol_ChainInventory) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.remainNum != rhs.remainNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_ChainInventory.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_ChainInventory.protoMessageName + ".BlockId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.number)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_ChainInventory.BlockId, rhs: Protocol_ChainInventory.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockInventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BlockInventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.ids)
      case 2: try decoder.decodeSingularEnumField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ids, fieldNumber: 1)
    }
    if self.type != .sync {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockInventory, rhs: Protocol_BlockInventory) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_BlockInventory.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SYNC"),
    1: .same(proto: "ADVTISE"),
    2: .same(proto: "FETCH"),
  ]
}

extension Protocol_BlockInventory.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_BlockInventory.protoMessageName + ".BlockId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.number)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_BlockInventory.BlockId, rhs: Protocol_BlockInventory.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Inventory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Inventory"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.ids)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .trx {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.ids.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.ids, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Inventory, rhs: Protocol_Inventory) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Inventory.InventoryType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TRX"),
    1: .same(proto: "BLOCK"),
  ]
}

extension Protocol_Items: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".Items"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "blocks"),
    3: .standard(proto: "block_headers"),
    4: .same(proto: "transactions"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.type)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.blocks)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.blockHeaders)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.transactions)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .err {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 2)
    }
    if !self.blockHeaders.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blockHeaders, fieldNumber: 3)
    }
    if !self.transactions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transactions, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_Items, rhs: Protocol_Items) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.blocks != rhs.blocks {return false}
    if lhs.blockHeaders != rhs.blockHeaders {return false}
    if lhs.transactions != rhs.transactions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_Items.ItemType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ERR"),
    1: .same(proto: "TRX"),
    2: .same(proto: "BLOCK"),
    3: .same(proto: "BLOCKHEADER"),
  ]
}

extension Protocol_DynamicProperties: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DynamicProperties"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "last_solidity_block_num"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.lastSolidityBlockNum)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.lastSolidityBlockNum != 0 {
      try visitor.visitSingularInt64Field(value: self.lastSolidityBlockNum, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DynamicProperties, rhs: Protocol_DynamicProperties) -> Bool {
    if lhs.lastSolidityBlockNum != rhs.lastSolidityBlockNum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DisconnectMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DisconnectMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reason"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.reason)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reason != .requested {
      try visitor.visitSingularEnumField(value: self.reason, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DisconnectMessage, rhs: Protocol_DisconnectMessage) -> Bool {
    if lhs.reason != rhs.reason {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_HelloMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".HelloMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "version"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "genesisBlockId"),
    5: .same(proto: "solidBlockId"),
    6: .same(proto: "headBlockId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._from)
      case 2: try decoder.decodeSingularInt32Field(value: &self.version)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 4: try decoder.decodeSingularMessageField(value: &self._genesisBlockID)
      case 5: try decoder.decodeSingularMessageField(value: &self._solidBlockID)
      case 6: try decoder.decodeSingularMessageField(value: &self._headBlockID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._from {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.version != 0 {
      try visitor.visitSingularInt32Field(value: self.version, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if let v = self._genesisBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._solidBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._headBlockID {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_HelloMessage, rhs: Protocol_HelloMessage) -> Bool {
    if lhs._from != rhs._from {return false}
    if lhs.version != rhs.version {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs._genesisBlockID != rhs._genesisBlockID {return false}
    if lhs._solidBlockID != rhs._solidBlockID {return false}
    if lhs._headBlockID != rhs._headBlockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_HelloMessage.BlockId: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_HelloMessage.protoMessageName + ".BlockId"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "number"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularInt64Field(value: &self.number)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if self.number != 0 {
      try visitor.visitSingularInt64Field(value: self.number, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_HelloMessage.BlockId, rhs: Protocol_HelloMessage.BlockId) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.number != rhs.number {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_InternalTransaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InternalTransaction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "caller_address"),
    3: .standard(proto: "transferTo_address"),
    4: .same(proto: "callValueInfo"),
    5: .same(proto: "note"),
    6: .same(proto: "rejected"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.hash)
      case 2: try decoder.decodeSingularBytesField(value: &self.callerAddress)
      case 3: try decoder.decodeSingularBytesField(value: &self.transferToAddress)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.callValueInfo)
      case 5: try decoder.decodeSingularBytesField(value: &self.note)
      case 6: try decoder.decodeSingularBoolField(value: &self.rejected)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 1)
    }
    if !self.callerAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.callerAddress, fieldNumber: 2)
    }
    if !self.transferToAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.transferToAddress, fieldNumber: 3)
    }
    if !self.callValueInfo.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.callValueInfo, fieldNumber: 4)
    }
    if !self.note.isEmpty {
      try visitor.visitSingularBytesField(value: self.note, fieldNumber: 5)
    }
    if self.rejected != false {
      try visitor.visitSingularBoolField(value: self.rejected, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_InternalTransaction, rhs: Protocol_InternalTransaction) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.callerAddress != rhs.callerAddress {return false}
    if lhs.transferToAddress != rhs.transferToAddress {return false}
    if lhs.callValueInfo != rhs.callValueInfo {return false}
    if lhs.note != rhs.note {return false}
    if lhs.rejected != rhs.rejected {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_InternalTransaction.CallValueInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_InternalTransaction.protoMessageName + ".CallValueInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "callValue"),
    2: .same(proto: "tokenId"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.callValue)
      case 2: try decoder.decodeSingularStringField(value: &self.tokenID)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.callValue != 0 {
      try visitor.visitSingularInt64Field(value: self.callValue, fieldNumber: 1)
    }
    if !self.tokenID.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_InternalTransaction.CallValueInfo, rhs: Protocol_InternalTransaction.CallValueInfo) -> Bool {
    if lhs.callValue != rhs.callValue {return false}
    if lhs.tokenID != rhs.tokenID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_DelegatedResourceAccountIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DelegatedResourceAccountIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "account"),
    2: .same(proto: "fromAccounts"),
    3: .same(proto: "toAccounts"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.account)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.fromAccounts)
      case 3: try decoder.decodeRepeatedBytesField(value: &self.toAccounts)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.account.isEmpty {
      try visitor.visitSingularBytesField(value: self.account, fieldNumber: 1)
    }
    if !self.fromAccounts.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.fromAccounts, fieldNumber: 2)
    }
    if !self.toAccounts.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.toAccounts, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_DelegatedResourceAccountIndex, rhs: Protocol_DelegatedResourceAccountIndex) -> Bool {
    if lhs.account != rhs.account {return false}
    if lhs.fromAccounts != rhs.fromAccounts {return false}
    if lhs.toAccounts != rhs.toAccounts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".NodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "beginSyncNum"),
    2: .same(proto: "block"),
    3: .same(proto: "solidityBlock"),
    4: .same(proto: "currentConnectCount"),
    5: .same(proto: "activeConnectCount"),
    6: .same(proto: "passiveConnectCount"),
    7: .same(proto: "totalFlow"),
    8: .same(proto: "peerInfoList"),
    9: .same(proto: "configNodeInfo"),
    10: .same(proto: "machineInfo"),
    11: .same(proto: "cheatWitnessInfoMap"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.beginSyncNum)
      case 2: try decoder.decodeSingularStringField(value: &self.block)
      case 3: try decoder.decodeSingularStringField(value: &self.solidityBlock)
      case 4: try decoder.decodeSingularInt32Field(value: &self.currentConnectCount)
      case 5: try decoder.decodeSingularInt32Field(value: &self.activeConnectCount)
      case 6: try decoder.decodeSingularInt32Field(value: &self.passiveConnectCount)
      case 7: try decoder.decodeSingularInt64Field(value: &self.totalFlow)
      case 8: try decoder.decodeRepeatedMessageField(value: &self.peerInfoList)
      case 9: try decoder.decodeSingularMessageField(value: &self._configNodeInfo)
      case 10: try decoder.decodeSingularMessageField(value: &self._machineInfo)
      case 11: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.cheatWitnessInfoMap)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.beginSyncNum != 0 {
      try visitor.visitSingularInt64Field(value: self.beginSyncNum, fieldNumber: 1)
    }
    if !self.block.isEmpty {
      try visitor.visitSingularStringField(value: self.block, fieldNumber: 2)
    }
    if !self.solidityBlock.isEmpty {
      try visitor.visitSingularStringField(value: self.solidityBlock, fieldNumber: 3)
    }
    if self.currentConnectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.currentConnectCount, fieldNumber: 4)
    }
    if self.activeConnectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.activeConnectCount, fieldNumber: 5)
    }
    if self.passiveConnectCount != 0 {
      try visitor.visitSingularInt32Field(value: self.passiveConnectCount, fieldNumber: 6)
    }
    if self.totalFlow != 0 {
      try visitor.visitSingularInt64Field(value: self.totalFlow, fieldNumber: 7)
    }
    if !self.peerInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.peerInfoList, fieldNumber: 8)
    }
    if let v = self._configNodeInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._machineInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    if !self.cheatWitnessInfoMap.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.cheatWitnessInfoMap, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo, rhs: Protocol_NodeInfo) -> Bool {
    if lhs.beginSyncNum != rhs.beginSyncNum {return false}
    if lhs.block != rhs.block {return false}
    if lhs.solidityBlock != rhs.solidityBlock {return false}
    if lhs.currentConnectCount != rhs.currentConnectCount {return false}
    if lhs.activeConnectCount != rhs.activeConnectCount {return false}
    if lhs.passiveConnectCount != rhs.passiveConnectCount {return false}
    if lhs.totalFlow != rhs.totalFlow {return false}
    if lhs.peerInfoList != rhs.peerInfoList {return false}
    if lhs._configNodeInfo != rhs._configNodeInfo {return false}
    if lhs._machineInfo != rhs._machineInfo {return false}
    if lhs.cheatWitnessInfoMap != rhs.cheatWitnessInfoMap {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.PeerInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".PeerInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "lastSyncBlock"),
    2: .same(proto: "remainNum"),
    3: .same(proto: "lastBlockUpdateTime"),
    4: .same(proto: "syncFlag"),
    5: .same(proto: "headBlockTimeWeBothHave"),
    6: .same(proto: "needSyncFromPeer"),
    7: .same(proto: "needSyncFromUs"),
    8: .same(proto: "host"),
    9: .same(proto: "port"),
    10: .same(proto: "nodeId"),
    11: .same(proto: "connectTime"),
    12: .same(proto: "avgLatency"),
    13: .same(proto: "syncToFetchSize"),
    14: .same(proto: "syncToFetchSizePeekNum"),
    15: .same(proto: "syncBlockRequestedSize"),
    16: .same(proto: "unFetchSynNum"),
    17: .same(proto: "blockInPorcSize"),
    18: .same(proto: "headBlockWeBothHave"),
    19: .same(proto: "isActive"),
    20: .same(proto: "score"),
    21: .same(proto: "nodeCount"),
    22: .same(proto: "inFlow"),
    23: .same(proto: "disconnectTimes"),
    24: .same(proto: "localDisconnectReason"),
    25: .same(proto: "remoteDisconnectReason"),
  ]

  fileprivate class _StorageClass {
    var _lastSyncBlock: String = String()
    var _remainNum: Int64 = 0
    var _lastBlockUpdateTime: Int64 = 0
    var _syncFlag: Bool = false
    var _headBlockTimeWeBothHave: Int64 = 0
    var _needSyncFromPeer: Bool = false
    var _needSyncFromUs: Bool = false
    var _host: String = String()
    var _port: Int32 = 0
    var _nodeID: String = String()
    var _connectTime: Int64 = 0
    var _avgLatency: Double = 0
    var _syncToFetchSize: Int32 = 0
    var _syncToFetchSizePeekNum: Int64 = 0
    var _syncBlockRequestedSize: Int32 = 0
    var _unFetchSynNum: Int64 = 0
    var _blockInPorcSize: Int32 = 0
    var _headBlockWeBothHave: String = String()
    var _isActive: Bool = false
    var _score: Int32 = 0
    var _nodeCount: Int32 = 0
    var _inFlow: Int64 = 0
    var _disconnectTimes: Int32 = 0
    var _localDisconnectReason: String = String()
    var _remoteDisconnectReason: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _lastSyncBlock = source._lastSyncBlock
      _remainNum = source._remainNum
      _lastBlockUpdateTime = source._lastBlockUpdateTime
      _syncFlag = source._syncFlag
      _headBlockTimeWeBothHave = source._headBlockTimeWeBothHave
      _needSyncFromPeer = source._needSyncFromPeer
      _needSyncFromUs = source._needSyncFromUs
      _host = source._host
      _port = source._port
      _nodeID = source._nodeID
      _connectTime = source._connectTime
      _avgLatency = source._avgLatency
      _syncToFetchSize = source._syncToFetchSize
      _syncToFetchSizePeekNum = source._syncToFetchSizePeekNum
      _syncBlockRequestedSize = source._syncBlockRequestedSize
      _unFetchSynNum = source._unFetchSynNum
      _blockInPorcSize = source._blockInPorcSize
      _headBlockWeBothHave = source._headBlockWeBothHave
      _isActive = source._isActive
      _score = source._score
      _nodeCount = source._nodeCount
      _inFlow = source._inFlow
      _disconnectTimes = source._disconnectTimes
      _localDisconnectReason = source._localDisconnectReason
      _remoteDisconnectReason = source._remoteDisconnectReason
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._lastSyncBlock)
        case 2: try decoder.decodeSingularInt64Field(value: &_storage._remainNum)
        case 3: try decoder.decodeSingularInt64Field(value: &_storage._lastBlockUpdateTime)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._syncFlag)
        case 5: try decoder.decodeSingularInt64Field(value: &_storage._headBlockTimeWeBothHave)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._needSyncFromPeer)
        case 7: try decoder.decodeSingularBoolField(value: &_storage._needSyncFromUs)
        case 8: try decoder.decodeSingularStringField(value: &_storage._host)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._port)
        case 10: try decoder.decodeSingularStringField(value: &_storage._nodeID)
        case 11: try decoder.decodeSingularInt64Field(value: &_storage._connectTime)
        case 12: try decoder.decodeSingularDoubleField(value: &_storage._avgLatency)
        case 13: try decoder.decodeSingularInt32Field(value: &_storage._syncToFetchSize)
        case 14: try decoder.decodeSingularInt64Field(value: &_storage._syncToFetchSizePeekNum)
        case 15: try decoder.decodeSingularInt32Field(value: &_storage._syncBlockRequestedSize)
        case 16: try decoder.decodeSingularInt64Field(value: &_storage._unFetchSynNum)
        case 17: try decoder.decodeSingularInt32Field(value: &_storage._blockInPorcSize)
        case 18: try decoder.decodeSingularStringField(value: &_storage._headBlockWeBothHave)
        case 19: try decoder.decodeSingularBoolField(value: &_storage._isActive)
        case 20: try decoder.decodeSingularInt32Field(value: &_storage._score)
        case 21: try decoder.decodeSingularInt32Field(value: &_storage._nodeCount)
        case 22: try decoder.decodeSingularInt64Field(value: &_storage._inFlow)
        case 23: try decoder.decodeSingularInt32Field(value: &_storage._disconnectTimes)
        case 24: try decoder.decodeSingularStringField(value: &_storage._localDisconnectReason)
        case 25: try decoder.decodeSingularStringField(value: &_storage._remoteDisconnectReason)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._lastSyncBlock.isEmpty {
        try visitor.visitSingularStringField(value: _storage._lastSyncBlock, fieldNumber: 1)
      }
      if _storage._remainNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._remainNum, fieldNumber: 2)
      }
      if _storage._lastBlockUpdateTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._lastBlockUpdateTime, fieldNumber: 3)
      }
      if _storage._syncFlag != false {
        try visitor.visitSingularBoolField(value: _storage._syncFlag, fieldNumber: 4)
      }
      if _storage._headBlockTimeWeBothHave != 0 {
        try visitor.visitSingularInt64Field(value: _storage._headBlockTimeWeBothHave, fieldNumber: 5)
      }
      if _storage._needSyncFromPeer != false {
        try visitor.visitSingularBoolField(value: _storage._needSyncFromPeer, fieldNumber: 6)
      }
      if _storage._needSyncFromUs != false {
        try visitor.visitSingularBoolField(value: _storage._needSyncFromUs, fieldNumber: 7)
      }
      if !_storage._host.isEmpty {
        try visitor.visitSingularStringField(value: _storage._host, fieldNumber: 8)
      }
      if _storage._port != 0 {
        try visitor.visitSingularInt32Field(value: _storage._port, fieldNumber: 9)
      }
      if !_storage._nodeID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._nodeID, fieldNumber: 10)
      }
      if _storage._connectTime != 0 {
        try visitor.visitSingularInt64Field(value: _storage._connectTime, fieldNumber: 11)
      }
      if _storage._avgLatency != 0 {
        try visitor.visitSingularDoubleField(value: _storage._avgLatency, fieldNumber: 12)
      }
      if _storage._syncToFetchSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._syncToFetchSize, fieldNumber: 13)
      }
      if _storage._syncToFetchSizePeekNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._syncToFetchSizePeekNum, fieldNumber: 14)
      }
      if _storage._syncBlockRequestedSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._syncBlockRequestedSize, fieldNumber: 15)
      }
      if _storage._unFetchSynNum != 0 {
        try visitor.visitSingularInt64Field(value: _storage._unFetchSynNum, fieldNumber: 16)
      }
      if _storage._blockInPorcSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._blockInPorcSize, fieldNumber: 17)
      }
      if !_storage._headBlockWeBothHave.isEmpty {
        try visitor.visitSingularStringField(value: _storage._headBlockWeBothHave, fieldNumber: 18)
      }
      if _storage._isActive != false {
        try visitor.visitSingularBoolField(value: _storage._isActive, fieldNumber: 19)
      }
      if _storage._score != 0 {
        try visitor.visitSingularInt32Field(value: _storage._score, fieldNumber: 20)
      }
      if _storage._nodeCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._nodeCount, fieldNumber: 21)
      }
      if _storage._inFlow != 0 {
        try visitor.visitSingularInt64Field(value: _storage._inFlow, fieldNumber: 22)
      }
      if _storage._disconnectTimes != 0 {
        try visitor.visitSingularInt32Field(value: _storage._disconnectTimes, fieldNumber: 23)
      }
      if !_storage._localDisconnectReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._localDisconnectReason, fieldNumber: 24)
      }
      if !_storage._remoteDisconnectReason.isEmpty {
        try visitor.visitSingularStringField(value: _storage._remoteDisconnectReason, fieldNumber: 25)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.PeerInfo, rhs: Protocol_NodeInfo.PeerInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._lastSyncBlock != rhs_storage._lastSyncBlock {return false}
        if _storage._remainNum != rhs_storage._remainNum {return false}
        if _storage._lastBlockUpdateTime != rhs_storage._lastBlockUpdateTime {return false}
        if _storage._syncFlag != rhs_storage._syncFlag {return false}
        if _storage._headBlockTimeWeBothHave != rhs_storage._headBlockTimeWeBothHave {return false}
        if _storage._needSyncFromPeer != rhs_storage._needSyncFromPeer {return false}
        if _storage._needSyncFromUs != rhs_storage._needSyncFromUs {return false}
        if _storage._host != rhs_storage._host {return false}
        if _storage._port != rhs_storage._port {return false}
        if _storage._nodeID != rhs_storage._nodeID {return false}
        if _storage._connectTime != rhs_storage._connectTime {return false}
        if _storage._avgLatency != rhs_storage._avgLatency {return false}
        if _storage._syncToFetchSize != rhs_storage._syncToFetchSize {return false}
        if _storage._syncToFetchSizePeekNum != rhs_storage._syncToFetchSizePeekNum {return false}
        if _storage._syncBlockRequestedSize != rhs_storage._syncBlockRequestedSize {return false}
        if _storage._unFetchSynNum != rhs_storage._unFetchSynNum {return false}
        if _storage._blockInPorcSize != rhs_storage._blockInPorcSize {return false}
        if _storage._headBlockWeBothHave != rhs_storage._headBlockWeBothHave {return false}
        if _storage._isActive != rhs_storage._isActive {return false}
        if _storage._score != rhs_storage._score {return false}
        if _storage._nodeCount != rhs_storage._nodeCount {return false}
        if _storage._inFlow != rhs_storage._inFlow {return false}
        if _storage._disconnectTimes != rhs_storage._disconnectTimes {return false}
        if _storage._localDisconnectReason != rhs_storage._localDisconnectReason {return false}
        if _storage._remoteDisconnectReason != rhs_storage._remoteDisconnectReason {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.ConfigNodeInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".ConfigNodeInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "codeVersion"),
    2: .same(proto: "p2pVersion"),
    3: .same(proto: "listenPort"),
    4: .same(proto: "discoverEnable"),
    5: .same(proto: "activeNodeSize"),
    6: .same(proto: "passiveNodeSize"),
    7: .same(proto: "sendNodeSize"),
    8: .same(proto: "maxConnectCount"),
    9: .same(proto: "sameIpMaxConnectCount"),
    10: .same(proto: "backupListenPort"),
    11: .same(proto: "backupMemberSize"),
    12: .same(proto: "backupPriority"),
    13: .same(proto: "dbVersion"),
    14: .same(proto: "minParticipationRate"),
    15: .same(proto: "supportConstant"),
    16: .same(proto: "minTimeRatio"),
    17: .same(proto: "maxTimeRatio"),
    18: .same(proto: "allowCreationOfContracts"),
    19: .same(proto: "allowAdaptiveEnergy"),
  ]

  fileprivate class _StorageClass {
    var _codeVersion: String = String()
    var _p2PVersion: String = String()
    var _listenPort: Int32 = 0
    var _discoverEnable: Bool = false
    var _activeNodeSize: Int32 = 0
    var _passiveNodeSize: Int32 = 0
    var _sendNodeSize: Int32 = 0
    var _maxConnectCount: Int32 = 0
    var _sameIpMaxConnectCount: Int32 = 0
    var _backupListenPort: Int32 = 0
    var _backupMemberSize: Int32 = 0
    var _backupPriority: Int32 = 0
    var _dbVersion: Int32 = 0
    var _minParticipationRate: Int32 = 0
    var _supportConstant: Bool = false
    var _minTimeRatio: Double = 0
    var _maxTimeRatio: Double = 0
    var _allowCreationOfContracts: Int64 = 0
    var _allowAdaptiveEnergy: Int64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _codeVersion = source._codeVersion
      _p2PVersion = source._p2PVersion
      _listenPort = source._listenPort
      _discoverEnable = source._discoverEnable
      _activeNodeSize = source._activeNodeSize
      _passiveNodeSize = source._passiveNodeSize
      _sendNodeSize = source._sendNodeSize
      _maxConnectCount = source._maxConnectCount
      _sameIpMaxConnectCount = source._sameIpMaxConnectCount
      _backupListenPort = source._backupListenPort
      _backupMemberSize = source._backupMemberSize
      _backupPriority = source._backupPriority
      _dbVersion = source._dbVersion
      _minParticipationRate = source._minParticipationRate
      _supportConstant = source._supportConstant
      _minTimeRatio = source._minTimeRatio
      _maxTimeRatio = source._maxTimeRatio
      _allowCreationOfContracts = source._allowCreationOfContracts
      _allowAdaptiveEnergy = source._allowAdaptiveEnergy
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._codeVersion)
        case 2: try decoder.decodeSingularStringField(value: &_storage._p2PVersion)
        case 3: try decoder.decodeSingularInt32Field(value: &_storage._listenPort)
        case 4: try decoder.decodeSingularBoolField(value: &_storage._discoverEnable)
        case 5: try decoder.decodeSingularInt32Field(value: &_storage._activeNodeSize)
        case 6: try decoder.decodeSingularInt32Field(value: &_storage._passiveNodeSize)
        case 7: try decoder.decodeSingularInt32Field(value: &_storage._sendNodeSize)
        case 8: try decoder.decodeSingularInt32Field(value: &_storage._maxConnectCount)
        case 9: try decoder.decodeSingularInt32Field(value: &_storage._sameIpMaxConnectCount)
        case 10: try decoder.decodeSingularInt32Field(value: &_storage._backupListenPort)
        case 11: try decoder.decodeSingularInt32Field(value: &_storage._backupMemberSize)
        case 12: try decoder.decodeSingularInt32Field(value: &_storage._backupPriority)
        case 13: try decoder.decodeSingularInt32Field(value: &_storage._dbVersion)
        case 14: try decoder.decodeSingularInt32Field(value: &_storage._minParticipationRate)
        case 15: try decoder.decodeSingularBoolField(value: &_storage._supportConstant)
        case 16: try decoder.decodeSingularDoubleField(value: &_storage._minTimeRatio)
        case 17: try decoder.decodeSingularDoubleField(value: &_storage._maxTimeRatio)
        case 18: try decoder.decodeSingularInt64Field(value: &_storage._allowCreationOfContracts)
        case 19: try decoder.decodeSingularInt64Field(value: &_storage._allowAdaptiveEnergy)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._codeVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._codeVersion, fieldNumber: 1)
      }
      if !_storage._p2PVersion.isEmpty {
        try visitor.visitSingularStringField(value: _storage._p2PVersion, fieldNumber: 2)
      }
      if _storage._listenPort != 0 {
        try visitor.visitSingularInt32Field(value: _storage._listenPort, fieldNumber: 3)
      }
      if _storage._discoverEnable != false {
        try visitor.visitSingularBoolField(value: _storage._discoverEnable, fieldNumber: 4)
      }
      if _storage._activeNodeSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._activeNodeSize, fieldNumber: 5)
      }
      if _storage._passiveNodeSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._passiveNodeSize, fieldNumber: 6)
      }
      if _storage._sendNodeSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sendNodeSize, fieldNumber: 7)
      }
      if _storage._maxConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._maxConnectCount, fieldNumber: 8)
      }
      if _storage._sameIpMaxConnectCount != 0 {
        try visitor.visitSingularInt32Field(value: _storage._sameIpMaxConnectCount, fieldNumber: 9)
      }
      if _storage._backupListenPort != 0 {
        try visitor.visitSingularInt32Field(value: _storage._backupListenPort, fieldNumber: 10)
      }
      if _storage._backupMemberSize != 0 {
        try visitor.visitSingularInt32Field(value: _storage._backupMemberSize, fieldNumber: 11)
      }
      if _storage._backupPriority != 0 {
        try visitor.visitSingularInt32Field(value: _storage._backupPriority, fieldNumber: 12)
      }
      if _storage._dbVersion != 0 {
        try visitor.visitSingularInt32Field(value: _storage._dbVersion, fieldNumber: 13)
      }
      if _storage._minParticipationRate != 0 {
        try visitor.visitSingularInt32Field(value: _storage._minParticipationRate, fieldNumber: 14)
      }
      if _storage._supportConstant != false {
        try visitor.visitSingularBoolField(value: _storage._supportConstant, fieldNumber: 15)
      }
      if _storage._minTimeRatio != 0 {
        try visitor.visitSingularDoubleField(value: _storage._minTimeRatio, fieldNumber: 16)
      }
      if _storage._maxTimeRatio != 0 {
        try visitor.visitSingularDoubleField(value: _storage._maxTimeRatio, fieldNumber: 17)
      }
      if _storage._allowCreationOfContracts != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowCreationOfContracts, fieldNumber: 18)
      }
      if _storage._allowAdaptiveEnergy != 0 {
        try visitor.visitSingularInt64Field(value: _storage._allowAdaptiveEnergy, fieldNumber: 19)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.ConfigNodeInfo, rhs: Protocol_NodeInfo.ConfigNodeInfo) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._codeVersion != rhs_storage._codeVersion {return false}
        if _storage._p2PVersion != rhs_storage._p2PVersion {return false}
        if _storage._listenPort != rhs_storage._listenPort {return false}
        if _storage._discoverEnable != rhs_storage._discoverEnable {return false}
        if _storage._activeNodeSize != rhs_storage._activeNodeSize {return false}
        if _storage._passiveNodeSize != rhs_storage._passiveNodeSize {return false}
        if _storage._sendNodeSize != rhs_storage._sendNodeSize {return false}
        if _storage._maxConnectCount != rhs_storage._maxConnectCount {return false}
        if _storage._sameIpMaxConnectCount != rhs_storage._sameIpMaxConnectCount {return false}
        if _storage._backupListenPort != rhs_storage._backupListenPort {return false}
        if _storage._backupMemberSize != rhs_storage._backupMemberSize {return false}
        if _storage._backupPriority != rhs_storage._backupPriority {return false}
        if _storage._dbVersion != rhs_storage._dbVersion {return false}
        if _storage._minParticipationRate != rhs_storage._minParticipationRate {return false}
        if _storage._supportConstant != rhs_storage._supportConstant {return false}
        if _storage._minTimeRatio != rhs_storage._minTimeRatio {return false}
        if _storage._maxTimeRatio != rhs_storage._maxTimeRatio {return false}
        if _storage._allowCreationOfContracts != rhs_storage._allowCreationOfContracts {return false}
        if _storage._allowAdaptiveEnergy != rhs_storage._allowAdaptiveEnergy {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.MachineInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.protoMessageName + ".MachineInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "threadCount"),
    2: .same(proto: "deadLockThreadCount"),
    3: .same(proto: "cpuCount"),
    4: .same(proto: "totalMemory"),
    5: .same(proto: "freeMemory"),
    6: .same(proto: "cpuRate"),
    7: .same(proto: "javaVersion"),
    8: .same(proto: "osName"),
    9: .same(proto: "jvmTotalMemoery"),
    10: .same(proto: "jvmFreeMemory"),
    11: .same(proto: "processCpuRate"),
    12: .same(proto: "memoryDescInfoList"),
    13: .same(proto: "deadLockThreadInfoList"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.threadCount)
      case 2: try decoder.decodeSingularInt32Field(value: &self.deadLockThreadCount)
      case 3: try decoder.decodeSingularInt32Field(value: &self.cpuCount)
      case 4: try decoder.decodeSingularInt64Field(value: &self.totalMemory)
      case 5: try decoder.decodeSingularInt64Field(value: &self.freeMemory)
      case 6: try decoder.decodeSingularDoubleField(value: &self.cpuRate)
      case 7: try decoder.decodeSingularStringField(value: &self.javaVersion)
      case 8: try decoder.decodeSingularStringField(value: &self.osName)
      case 9: try decoder.decodeSingularInt64Field(value: &self.jvmTotalMemoery)
      case 10: try decoder.decodeSingularInt64Field(value: &self.jvmFreeMemory)
      case 11: try decoder.decodeSingularDoubleField(value: &self.processCpuRate)
      case 12: try decoder.decodeRepeatedMessageField(value: &self.memoryDescInfoList)
      case 13: try decoder.decodeRepeatedMessageField(value: &self.deadLockThreadInfoList)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.threadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.threadCount, fieldNumber: 1)
    }
    if self.deadLockThreadCount != 0 {
      try visitor.visitSingularInt32Field(value: self.deadLockThreadCount, fieldNumber: 2)
    }
    if self.cpuCount != 0 {
      try visitor.visitSingularInt32Field(value: self.cpuCount, fieldNumber: 3)
    }
    if self.totalMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.totalMemory, fieldNumber: 4)
    }
    if self.freeMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.freeMemory, fieldNumber: 5)
    }
    if self.cpuRate != 0 {
      try visitor.visitSingularDoubleField(value: self.cpuRate, fieldNumber: 6)
    }
    if !self.javaVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.javaVersion, fieldNumber: 7)
    }
    if !self.osName.isEmpty {
      try visitor.visitSingularStringField(value: self.osName, fieldNumber: 8)
    }
    if self.jvmTotalMemoery != 0 {
      try visitor.visitSingularInt64Field(value: self.jvmTotalMemoery, fieldNumber: 9)
    }
    if self.jvmFreeMemory != 0 {
      try visitor.visitSingularInt64Field(value: self.jvmFreeMemory, fieldNumber: 10)
    }
    if self.processCpuRate != 0 {
      try visitor.visitSingularDoubleField(value: self.processCpuRate, fieldNumber: 11)
    }
    if !self.memoryDescInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.memoryDescInfoList, fieldNumber: 12)
    }
    if !self.deadLockThreadInfoList.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.deadLockThreadInfoList, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.MachineInfo, rhs: Protocol_NodeInfo.MachineInfo) -> Bool {
    if lhs.threadCount != rhs.threadCount {return false}
    if lhs.deadLockThreadCount != rhs.deadLockThreadCount {return false}
    if lhs.cpuCount != rhs.cpuCount {return false}
    if lhs.totalMemory != rhs.totalMemory {return false}
    if lhs.freeMemory != rhs.freeMemory {return false}
    if lhs.cpuRate != rhs.cpuRate {return false}
    if lhs.javaVersion != rhs.javaVersion {return false}
    if lhs.osName != rhs.osName {return false}
    if lhs.jvmTotalMemoery != rhs.jvmTotalMemoery {return false}
    if lhs.jvmFreeMemory != rhs.jvmFreeMemory {return false}
    if lhs.processCpuRate != rhs.processCpuRate {return false}
    if lhs.memoryDescInfoList != rhs.memoryDescInfoList {return false}
    if lhs.deadLockThreadInfoList != rhs.deadLockThreadInfoList {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.MachineInfo.MemoryDescInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.MachineInfo.protoMessageName + ".MemoryDescInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "initSize"),
    3: .same(proto: "useSize"),
    4: .same(proto: "maxSize"),
    5: .same(proto: "useRate"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularInt64Field(value: &self.initSize)
      case 3: try decoder.decodeSingularInt64Field(value: &self.useSize)
      case 4: try decoder.decodeSingularInt64Field(value: &self.maxSize)
      case 5: try decoder.decodeSingularDoubleField(value: &self.useRate)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.initSize != 0 {
      try visitor.visitSingularInt64Field(value: self.initSize, fieldNumber: 2)
    }
    if self.useSize != 0 {
      try visitor.visitSingularInt64Field(value: self.useSize, fieldNumber: 3)
    }
    if self.maxSize != 0 {
      try visitor.visitSingularInt64Field(value: self.maxSize, fieldNumber: 4)
    }
    if self.useRate != 0 {
      try visitor.visitSingularDoubleField(value: self.useRate, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.MachineInfo.MemoryDescInfo, rhs: Protocol_NodeInfo.MachineInfo.MemoryDescInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.initSize != rhs.initSize {return false}
    if lhs.useSize != rhs.useSize {return false}
    if lhs.maxSize != rhs.maxSize {return false}
    if lhs.useRate != rhs.useRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Protocol_NodeInfo.MachineInfo.protoMessageName + ".DeadLockThreadInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "lockName"),
    3: .same(proto: "lockOwner"),
    4: .same(proto: "state"),
    5: .same(proto: "blockTime"),
    6: .same(proto: "waitTime"),
    7: .same(proto: "stackTrace"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.lockName)
      case 3: try decoder.decodeSingularStringField(value: &self.lockOwner)
      case 4: try decoder.decodeSingularStringField(value: &self.state)
      case 5: try decoder.decodeSingularInt64Field(value: &self.blockTime)
      case 6: try decoder.decodeSingularInt64Field(value: &self.waitTime)
      case 7: try decoder.decodeSingularStringField(value: &self.stackTrace)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.lockName.isEmpty {
      try visitor.visitSingularStringField(value: self.lockName, fieldNumber: 2)
    }
    if !self.lockOwner.isEmpty {
      try visitor.visitSingularStringField(value: self.lockOwner, fieldNumber: 3)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 4)
    }
    if self.blockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.blockTime, fieldNumber: 5)
    }
    if self.waitTime != 0 {
      try visitor.visitSingularInt64Field(value: self.waitTime, fieldNumber: 6)
    }
    if !self.stackTrace.isEmpty {
      try visitor.visitSingularStringField(value: self.stackTrace, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo, rhs: Protocol_NodeInfo.MachineInfo.DeadLockThreadInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.lockName != rhs.lockName {return false}
    if lhs.lockOwner != rhs.lockOwner {return false}
    if lhs.state != rhs.state {return false}
    if lhs.blockTime != rhs.blockTime {return false}
    if lhs.waitTime != rhs.waitTime {return false}
    if lhs.stackTrace != rhs.stackTrace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
